
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sequence homology searching &#8212; An Introduction to Applied Bioinformatics</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Machine learning in bioinformatics" href="machine-learning.html" />
    <link rel="prev" title="Pairwise sequence alignment" href="pairwise-alignment.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">An Introduction to Applied Bioinformatics</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="introduction.html">
   Introduction
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="biological-information.html">
   Biological Information
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="pairwise-alignment.html">
   Pairwise sequence alignment
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Sequence homology searching
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="machine-learning.html">
   Machine learning in bioinformatics
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="_sources/database-searching.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/database-searching.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/applied-bioinformatics/iab2/main?urlpath=tree/book/database-searching.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defining-the-problem">
   Defining the problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loading-annotated-sequences">
   Loading annotated sequences
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   Defining the problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-complete-homology-search-function">
   A complete homology search function
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#reducing-the-runtime-for-database-searches">
   Reducing the runtime for database searches
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#heuristic-algorithms">
   Heuristic algorithms
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#random-reference-sequence-selection">
     Random reference sequence selection
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#composition-based-reference-sequence-collection">
     Composition-based reference sequence collection
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#gc-content">
       GC content
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#kmer-content">
       kmer content
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#further-optimizing-composition-based-approaches-by-pre-computing-reference-database-information">
       Further optimizing composition-based approaches by pre-computing reference database information
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#determining-the-statistical-significance-of-a-pairwise-alignment">
   Determining the statistical significance of a pairwise alignment
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metrics-of-alignment-quality">
     Metrics of alignment quality
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#false-positives-false-negatives-p-values-and-alpha">
     False positives, false negatives, p-values, and alpha
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#interpreting-alignment-scores-in-context">
     Interpreting alignment scores in context
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exploring-the-limit-of-detection-of-sequence-homology-searches">
     Exploring the limit of detection of sequence homology searches
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="sequence-homology-searching">
<h1>Sequence homology searching<a class="headerlink" href="#sequence-homology-searching" title="Permalink to this headline">¶</a></h1>
<p>In this chapter we’ll talk about using pairwise alignment to search databases of biological sequences with the goal of identifying sequence homology. We previously defined homology between a pair of sequences to mean that those sequences are derived from a common ancestral sequence. Homology searching is an essential part of making inferences about where a biological sequence came from, and/or what it does. In most cases, if you have an unannotated biological sequence, such as the following protein sequence, it’s very hard (really, impossible) to know what it is without more information.</p>
<p>What a researcher will often do is search this sequence, their <strong>query</strong>, against some <strong>reference database</strong> of annotated sequences to learn what function the sequence performs (if the reference database contains functional annotation of sequences) and/or what organisms are likely to encode this sequence in their genome (if the reference database contains taxonomic annotation of sequences).</p>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p>Whose genome is the following sequence encoded in? What is its function? Take a minute now to answer these questions using the <a class="reference external" href="https://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastp&amp;PAGE_TYPE=BlastSearch&amp;LINK_LOC=blasthome">Protein BLAST homology search tool on the NCBI website</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="n">mystery</span><span class="o">-</span><span class="n">sequence1</span>
<span class="n">MFVFLVLLPLVSSQCVNLTTRTQLPPAYTNSFTRGVYYPDKVFRSSVLHSTQDLFLPFFS</span>
<span class="n">NVTWFHAIHVSGTNGTKRFDNPVLPFNDGVYFASTEKSNIIRGWIFGTTLDSKTQSLLIV</span>
<span class="n">NNATNVVIKVCEFQFCNDPFLGVYYHKNNKSWMESEFRVYSSANNCTFEYVSQPFLMDLE</span>
<span class="n">GKQGNFKNLREFVFKNIDGYFKIYSKHTPINLVRDLPQGFSALEPLVDLPIGINITRFQT</span>
<span class="n">LLALHRSYLTPGDSSSGWTAGAAAYYVGYLQPRTFLLKYNENGTITDAVDCALDPLSETK</span>
<span class="n">CTLKSFTVEKGIYQTSNFRVQPTESIVRFPNITNLCPFGEVFNATRFASVYAWNRKRISN</span>
<span class="n">CVADYSVLYNSASFSTFKCYGVSPTKLNDLCFTNVYADSFVIRGDEVRQIAPGQTGKIAD</span>
<span class="n">YNYKLPDDFTGCVIAWNSNNLDSKVGGNYNYLYRLFRKSNLKPFERDISTEIYQAGSTPC</span>
<span class="n">NGVEGFNCYFPLQSYGFQPTNGVGYQPYRVVVLSFELLHAPATVCGPKKSTNLVKNKCVN</span>
<span class="n">FNFNGLTGTGVLTESNKKFLPFQQFGRDIADTTDAVRDPQTLEILDITPCSFGGVSVITP</span>
<span class="n">GTNTSNQVAVLYQDVNCTEVPVAIHADQLTPTWRVYSTGSNVFQTRAGCLIGAEHVNNSY</span>
<span class="n">ECDIPIGAGICASYQTQTNSPRRARSVASQSIIAYTMSLGAENSVAYSNNSIAIPTNFTI</span>
<span class="n">SVTTEILPVSMTKTSVDCTMYICGDSTECSNLLLQYGSFCTQLNRALTGIAVEQDKNTQE</span>
<span class="n">VFAQVKQIYKTPPIKDFGGFNFSQILPDPSKPSKRSFIEDLLFNKVTLADAGFIKQYGDC</span>
<span class="n">LGDIAARDLICAQKFNGLTVLPPLLTDEMIAQYTSALLAGTITSGWTFGAGAALQIPFAM</span>
<span class="n">QMAYRFNGIGVTQNVLYENQKLIANQFNSAIGKIQDSLSSTASALGKLQDVVNQNAQALN</span>
<span class="n">TLVKQLSSNFGAISSVLNDILSRLDKVEAEVQIDRLITGRLQSLQTYVTQQLIRAAEIRA</span>
<span class="n">SANLAATKMSECVLGQSKRVDFCGKGYHLMSFPQSAPHGVVFLHVTYVPAQEKNFTTAPA</span>
<span class="n">ICHDGKAHFPREGVFVSNGTHWFVTQRNFYEPQIITTDNTFVSGNCDVVIGIVNNTVYDP</span>
<span class="n">LQPELDSFKEELDKYFKNHTSPDVDLGDISGINASVVNIQKEIDRLNEVAKNLNESLIDL</span>
<span class="n">QELGKYEQYIKWPWYIWLGFIAGLIAIVMVTIMLCCMTSCCSCLKGCCSCGSCCKFDEDD</span>
<span class="n">SEPVLKGVKLHYT</span>
</pre></div>
</div>
</div>
<p>In the context of database searching, a query sequence and a reference sequence that we hypothesize to be homologous can be identical to one another, or they can differ as a result of mutation events. When sequences differ, we’re often then interested in how much they differ, or their pairwise similarity, which can help us identify the most closely related of several homologs in the reference database. There is an important distinction in the terms <strong>homology</strong> and <strong>similarity</strong>: homology is a discrete variable, and similarity is a continuous variable. A pair of biological sequences either <em>are</em> or <em>are not</em> derived from a common ancestor, but they can be more or less similar to each other. Saying that two sequences are 80% homologous doesn’t make sense. What people generally mean when they say this is that two sequences are 80% similar, and as a result they are hypothesizing homology between the sequences.</p>
<p><strong>Similarity</strong> between a pair of sequences can be computed in a few different ways. In this text, unless otherwise noted, we’ll compute similar as: <span class="math notranslate nohighlight">\(Similarity = 1 - Hamming\ distance\)</span>. Recall that Hamming distance is the fraction of positions that differ between aligned sequences. Similarity is therefore the inverse of that: the fraction of positions that do not differ between aligned sequences.</p>
<div class="section" id="defining-the-problem">
<h2>Defining the problem<a class="headerlink" href="#defining-the-problem" title="Permalink to this headline">¶</a></h2>
<p>As mentioned above, if we want to perform a homology search we’ll have one or more <strong>query sequences</strong>, and for each we want to know which sequence(s) in a reference database it is most similar to.</p>
<p>Sequence homology searching can be implemented in a few ways. In this chapter, we’ll use the local alignment function that we worked with in the Pairwise Alignment chapter, <code class="docutils literal notranslate"><span class="pre">local_pairwise_align_ssw</span></code>, run it many times to search one query sequence against many reference sequences, and investigate the highest scoring alignment(s) to identify the best database match. Remember that you can always get help with a function by passing it as an argument to <code class="docutils literal notranslate"><span class="pre">help</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">skbio.alignment</span> <span class="kn">import</span> <span class="n">local_pairwise_align_ssw</span>
<span class="n">help</span><span class="p">(</span><span class="n">local_pairwise_align_ssw</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on function local_pairwise_align_ssw in module skbio.alignment._pairwise:

local_pairwise_align_ssw(sequence1, sequence2, **kwargs)
    Align query and target sequences with Striped Smith-Waterman.
    
    State: Experimental as of 0.4.0.
    
    Parameters
    ----------
    sequence1 : DNA, RNA, or Protein
        The first unaligned sequence
    sequence2 : DNA, RNA, or Protein
        The second unaligned sequence
    
    Returns
    -------
    tuple
        ``TabularMSA`` object containing the aligned sequences, alignment score
        (float), and start/end positions of each input sequence (iterable
        of two-item tuples). Note that start/end positions are indexes into the
        unaligned sequences.
    
    Notes
    -----
    This is a wrapper for the SSW package [1]_.
    
    For a complete list of optional keyword-arguments that can be provided,
    see ``skbio.alignment.StripedSmithWaterman``.
    
    The following kwargs will not have any effect: `suppress_sequences`,
    `zero_index`, and `protein`
    
    If an alignment does not meet a provided filter, `None` will be returned.
    
    References
    ----------
    .. [1] Zhao, Mengyao, Wan-Ping Lee, Erik P. Garrison, &amp; Gabor T.
       Marth. &quot;SSW Library: An SIMD Smith-Waterman C/C++ Library for
       Applications&quot;. PLOS ONE (2013). Web. 11 July 2014.
       http://www.plosone.org/article/info:doi/10.1371/journal.pone.0082138
    
    See Also
    --------
    skbio.alignment.StripedSmithWaterman
</pre></div>
</div>
</div>
</div>
<p>When our reference database starts getting hundreds of millions of bases long (as would be the case if we were searching against 97% OTUs from the <a class="reference external" href="http://www.ncbi.nlm.nih.gov/pubmed/22134646">Greengenes small-subunit ribosomal RNA (SSU rRNA) reference database</a>), billions of bases long (as would be the case if we were searching against <a class="reference external" href="https://genome.ucsc.edu/cgi-bin/hgGateway">the human genome</a>) or trillions of bases long (as would be the case if we were searching against the <a class="reference external" href="http://www.ncbi.nlm.nih.gov/refseq/">NCBI non-redundant nucleotide database</a>), runtime becomes an important consideration. For that reason, learning about <em>heuristic algorithms</em> is an essential part of learning about sequence homology searching. Heuristic algorithms apply some rules (i.e., heuristics) to approximate the correct solution to a problem in a fraction of the runtime that would be required if we wanted to be guaranteed to find the correct solution. Heuristic algorithms are very common in bioinformatics, and we’ll use them in several other places in this book.</p>
<p>While we’ll be aligning nucleotide sequences in this chapter, the same concepts apply to protein homology searching.</p>
</div>
<div class="section" id="loading-annotated-sequences">
<span id="load-qdr"></span><h2>Loading annotated sequences<a class="headerlink" href="#loading-annotated-sequences" title="Permalink to this headline">¶</a></h2>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We’re accessing Greengenes sequences here through the <a class="reference external" href="https://github.com/biocore/qiime-default-reference">QIIME default reference project</a>. The QIIME default reference project isn’t actually used by recent versions of QIIME but it’s a convenient resource for accessing a collection of 16S sequences from Python. This resource is handy if you need some sequences for experimental purposes, but is outdated and shouldn’t be used in practice.</p>
</div>
</div>
<p>The first thing we’ll do as we learn about sequence homology searching is load some annotated sequences. The sequences that we’re going to work with are derived from the <a class="reference external" href="http://greengenes.secondgenome.com/">Greengenes</a> database. Greengenes is a database of 16S rRNA gene sequences, a component of the archaeal and bacterial <a class="reference external" href="http://www.nature.com/scitable/definition/ribosome-194">ribosome</a> (the molecular machine that drives translation of mRNA to proteins). This gene is of a lot of interest to biologists because it’s one of about 200 genes that are encoded in the genomes of all known cellular organisms. The sequences in Greengenes are taxonomically annotated, meaning that we’ll have a collection of gene sequences and the taxonomic identity of the organism whose genome the sequence is found in. If we search an unannotated 16S rRNA query sequence against this database, we can make inferences about what organism our query sequence is from.</p>
<p>First, let’s load Greengenes into a list of <code class="docutils literal notranslate"><span class="pre">skbio.DNA</span></code> sequence objects, and associate the taxonomy of each sequence as sequence metadata.</p>
<div class="cell tag_hide-cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This cell performs some configuration for this notebook. It&#39;s hidden by</span>
<span class="c1"># default because it&#39;s not relevant to the content of this chapter. You&#39;ll</span>
<span class="c1"># occasionally notice that I hide this type of information so it&#39;s not </span>
<span class="c1"># distracting.</span>

<span class="o">%</span><span class="k">pylab</span> inline

<span class="kn">from</span> <span class="nn">IPython.core</span> <span class="kn">import</span> <span class="n">page</span>
<span class="n">page</span><span class="o">.</span><span class="n">page</span> <span class="o">=</span> <span class="nb">print</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Populating the interactive namespace from numpy and matplotlib
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiime_default_reference</span> <span class="k">as</span> <span class="nn">qdr</span>
<span class="kn">import</span> <span class="nn">skbio</span>

<span class="k">def</span> <span class="nf">load_taxonomy_reference_database</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># Load the taxonomic data</span>
    <span class="n">reference_taxonomy</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">qdr</span><span class="o">.</span><span class="n">get_reference_taxonomy</span><span class="p">()):</span>
        <span class="n">seq_id</span><span class="p">,</span> <span class="n">seq_tax</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">reference_taxonomy</span><span class="p">[</span><span class="n">seq_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq_tax</span>

    <span class="c1"># Load the reference sequences, and associate the taxonomic annotation with</span>
    <span class="c1"># each as metadata</span>
    <span class="n">reference_db</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">skbio</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">qdr</span><span class="o">.</span><span class="n">get_reference_sequences</span><span class="p">(),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;fasta&#39;</span><span class="p">,</span> <span class="n">constructor</span><span class="o">=</span><span class="n">skbio</span><span class="o">.</span><span class="n">DNA</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">has_degenerates</span><span class="p">():</span>
            <span class="c1"># For the purpose of this lesson, we&#39;re going to ignore sequences that contain</span>
            <span class="c1"># degenerate characters (i.e., characters other than A, C, G, or T)</span>
            <span class="k">continue</span>
        <span class="n">seq_tax</span> <span class="o">=</span> <span class="n">reference_taxonomy</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]]</span>
        <span class="n">e</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;taxonomy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq_tax</span>
        <span class="n">reference_db</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> sequences were loaded from the reference database.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_db</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">reference_taxonomy</span><span class="p">,</span> <span class="n">reference_db</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">reference_taxonomy</span><span class="p">,</span> <span class="n">reference_db</span> <span class="o">=</span> <span class="n">load_taxonomy_reference_database</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>88452 sequences were loaded from the reference database.
</pre></div>
</div>
</div>
</div>
<p>Next, we’ll just inspect a couple of the sequences we loaded. Notice how the specificity of our taxonomic annotations (i.e., how many taxonomic levels are annotated and unknown) differs for different sequences.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">reference_db</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
-----------------------------------------------------------------------
Metadata:
    &#39;description&#39;: &#39;&#39;
    &#39;id&#39;: &#39;1111883&#39;
    &#39;taxonomy&#39;: &#39;k__Bacteria; p__Gemmatimonadetes; c__Gemm-1; o__; f__;
                 g__; s__&#39;
Stats:
    length: 1428
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 61.90%
-----------------------------------------------------------------------
0    GCTGGCGGCG TGCCTAACAC ATGTAAGTCG AACGGGACTG GGGGCAACTC CAGTTCAGTG
60   GCAGACGGGT GCGTAACACG TGAGCAACTT GTCCGACGGC GGGGGATAGC CGGCCCAACG
...
1320 GCCGCGGTGA ATACGTTCCC GGGCCTTGTA CACACCGCCC GTCACGCCAT GGAAGCCGGA
1380 GGGACCCGAA ACCGGTGGGC CAACCGCAAG GGGGCAGCCG TCTAAGGT
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">reference_db</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
----------------------------------------------------------------------
Metadata:
    &#39;description&#39;: &#39;&#39;
    &#39;id&#39;: &#39;4483258&#39;
    &#39;taxonomy&#39;: &#39;k__Archaea; p__Crenarchaeota; c__Thermoprotei;
                 o__Thermoproteales; f__Thermoproteaceae; g__; s__&#39;
Stats:
    length: 2123
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 58.36%
----------------------------------------------------------------------
0    CTGGTTGATC CTGCCGGACC CGACCGCTAT CGGGGTGGGG CTTAGCCATG CGAGTCAAGC
60   GCCCCAGGGA CCCGCTGGGG TGCGGCGCAC GGCTCAGTAA CACGTGGCCA ACCTACCCTC
...
2040 ATAATCTCCT TATTGTCTGA TCCTTATGCA TTTTCCTTTG GCCCATCCCG TGAATACGCG
2100 CGGTGAATAC GTCCCTGCCC CTT
</pre></div>
</div>
</div>
</div>
<p>For the sake of runtime, we’re going to work through this chapter using a random sample of sequences from this database. Here we’ll use Python’s <a class="reference external" href="https://docs.python.org/3/library/random.html">random module</a> to select sequences at random.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="n">reference_db</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">reference_db</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> sequences are present in the subsampled database.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_db</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5000 sequences are present in the subsampled database.
</pre></div>
</div>
</div>
</div>
<p>We’ll also extract some sequences from Greengenes to use as query sequences in our database searches. This time we won’t annotate them (to simulate not knowing what organisms they’re from). We’ll also trim these sequences so they’re shorter than the full length references. This will simulate obtaining a partial gene sequence, as is most common with the current sequencing technologies (as of this writing), but will also help to make the examples run faster.</p>
<p>Note that some of our query sequences may also be in our subsampled reference database and some won’t. This is realistic: sometimes we’re working with sequences that are exact matches to known sequences, and sometimes we’re working with sequences that don’t match any known sequences (or at least any in the reference database that we’re working with).</p>
<div class="cell tag_hide-cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_taxonomy_query_sequences</span><span class="p">(</span><span class="n">start_position</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="n">queries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">skbio</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">qdr</span><span class="o">.</span><span class="n">get_reference_sequences</span><span class="p">(),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;fasta&#39;</span><span class="p">,</span> <span class="n">constructor</span><span class="o">=</span><span class="n">skbio</span><span class="o">.</span><span class="n">DNA</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">has_degenerates</span><span class="p">():</span>
            <span class="c1"># For the purpose of this lesson, we&#39;re going to ignore sequences that contain</span>
            <span class="c1"># degenerate characters (i.e., characters other than A, C, G, or T)</span>
            <span class="k">continue</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">start_position</span><span class="p">:</span><span class="n">start_position</span> <span class="o">+</span> <span class="n">length</span><span class="p">]</span>
        <span class="n">queries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">queries</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">queries</span> <span class="o">=</span> <span class="n">load_taxonomy_query_sequences</span><span class="p">()</span>
<span class="n">queries</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s inspect a couple of the query sequences that we’ll work with.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">queries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
---------------------------------------------------------------------
Metadata:
    &#39;description&#39;: &#39;&#39;
    &#39;id&#39;: &#39;1110988&#39;
Stats:
    length: 200
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 46.50%
---------------------------------------------------------------------
0   GGTGAGTAAC ACGTGAGCAA CCTGCCTTTG AGAGAGGGAT AGCTTCGGGA AACTGATGGT
60  AATACCTCAT AACATATATT TAAGGCATCT TAGATATATC AAAGATTTAT CACTCAAAGA
120 TGGGCTCGCG TCTGATTAGC TGGTTGGTGA GGTAGCGGCT CACCAAGGCG ACGATCAGTA
180 GCCGGACTGA GAGGTTGAAC
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">queries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
---------------------------------------------------------------------
Metadata:
    &#39;description&#39;: &#39;&#39;
    &#39;id&#39;: &#39;547906&#39;
Stats:
    length: 200
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 51.50%
---------------------------------------------------------------------
0   GTGGGCAACC TGCCCTATAC TGGGGAATAA TCACTGGAAA CGGTGACTAA TACCGCATGT
60  CATTGCGAGG GGGCATCCTC TTGCAAGAAA AGGAATTTAT TTCGGTATAG GATGGGCCCG
120 CATCTGATTA GCTAGTTGGT GAGATAACAG CCCACCAAGG CGACGATCAG TAGCCGACCT
180 GAGAGGGTGA TCGGCCACAT
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id1">
<h2>Defining the problem<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>The problem that we are going to address here is as follows. We now have a query sequence (<span class="math notranslate nohighlight">\(q_i\)</span>) which is not taxonomically annotated (meaning we don’t know the taxonomy of the organism whose genome it is found in), and a reference database (<span class="math notranslate nohighlight">\(R\)</span>) of taxonomically annotated sequences (<span class="math notranslate nohighlight">\(r_1, r_2, r_3, ... r_n\)</span>). We want to infer a taxonomic annotation for <span class="math notranslate nohighlight">\(q_i\)</span>. We’ll do this by identifying the most similar sequence(s) in <span class="math notranslate nohighlight">\(R\)</span> and associating their taxonomy with <span class="math notranslate nohighlight">\(q_i\)</span>. Because we actually do know the taxonomy of <span class="math notranslate nohighlight">\(q_i\)</span> (to the extent that we trust the annotations in <span class="math notranslate nohighlight">\(R\)</span>), we can evaluate how well this approach works.</p>
<p>There are a few realistic features of the situation that we’ve set up here that I want you to be aware of.</p>
<ol class="simple">
<li><p>All of the query and reference sequences are homologous. In this case, they are all sequences of the 16S rRNA gene from archaea and bacteria. This may or may not be the case in real-world applications. Sometimes you’ll work with gene-specific databases such as Greengenes, and sometimes you’ll work with non-specific databases such as the NCBI nucleotide database (nr). Regardless, the search process is similar.</p></li>
<li><p>The distance between each query sequence and its most closely related sequences in <span class="math notranslate nohighlight">\(R\)</span> will vary widely. Sometimes <span class="math notranslate nohighlight">\(q\)</span> will be an exact match to a reference sequence <span class="math notranslate nohighlight">\(r_i\)</span>, and sometimes we may have as little as <span class="math notranslate nohighlight">\(50\%\)</span> similarity.</p></li>
</ol>
<p>As we work through the next sections, imagine that we’re exploring scaling this system up, so that instead of searching just one or a few query sequences against the reference database, we ultimately want to apply this to search millions of sequences against the database. This would be the real-world problem we faced if we had collected 16S rRNA sequences from the environment (which would of course be unannotated) using high-throughput DNA sequencing.</p>
</div>
<div class="section" id="a-complete-homology-search-function">
<h2>A complete homology search function<a class="headerlink" href="#a-complete-homology-search-function" title="Permalink to this headline">¶</a></h2>
<p>Let’s define a homology search function that aligns each provided query sequences <span class="math notranslate nohighlight">\(q_i\)</span> with each of our reference database sequences (<span class="math notranslate nohighlight">\(r_1, r_2, r_3, ... r_n\)</span>). This function will take as input one or more query sequences, and the reference database. We’ll call the top scoring alignments for each <span class="math notranslate nohighlight">\(q_i\)</span> the <em>best hits</em>, and we’ll specifically request some number (<code class="docutils literal notranslate"><span class="pre">n</span></code>) of best hits for each <span class="math notranslate nohighlight">\(q_i\)</span>. The output of this function will be a summary of the <code class="docutils literal notranslate"><span class="pre">n</span></code> best hits for each query sequence, including some technical information about the alignment and the taxonomy associated with the corresponding reference sequence. We’ll then review the taxonomy annotations for our best hits, and from those make an inference about the taxonomy annotation for <span class="math notranslate nohighlight">\(q_i\)</span>.</p>
<p>Spend a minute looking at this function and try to understand what it’s doing.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">skbio.alignment</span> <span class="kn">import</span> <span class="n">local_pairwise_align_ssw</span>

<span class="k">def</span> <span class="nf">local_alignment_search</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                           <span class="n">aligner</span><span class="o">=</span><span class="n">local_pairwise_align_ssw</span><span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
        <span class="c1"># first we&#39;ll compute all of the alignments and their associated scores</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reference_db</span><span class="p">:</span>
            <span class="n">aln</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">aligner</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">hits</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">score</span><span class="p">,</span> <span class="n">aln</span><span class="p">,</span>
                         <span class="n">r</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;taxonomy&#39;</span><span class="p">]])</span>
        <span class="c1"># then we reverse-sort them by score, and return the n highest</span>
        <span class="c1"># scoring alignments (this needs to be updated so we only</span>
        <span class="c1"># ever keep track of the n highest scoring alignments)</span>
        <span class="n">best_hits</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">hits</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_hits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if there are no hits, log that information</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">q</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="s2">&quot;no matches&quot;</span><span class="p">))</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;n/a&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># otherwise compile and track some information about the n</span>
            <span class="c1"># best hits</span>
            <span class="k">for</span> <span class="n">r_id</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">aln</span><span class="p">,</span> <span class="n">r_tax</span> <span class="ow">in</span> <span class="n">best_hits</span><span class="p">:</span>
                <span class="n">percent_similarity</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">aln</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">aln</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                <span class="n">aln_length</span> <span class="o">=</span> <span class="n">aln</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">q</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">r_id</span><span class="p">))</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r_tax</span><span class="p">,</span> <span class="n">percent_similarity</span><span class="p">,</span>
                                <span class="n">aln_length</span><span class="p">,</span> <span class="n">score</span><span class="p">))</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;query&#39;</span><span class="p">,</span> <span class="s1">&#39;reference&#39;</span><span class="p">])</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;reference taxonomy&#39;</span><span class="p">,</span> <span class="s1">&#39;percent similarity&#39;</span><span class="p">,</span>
               <span class="s1">&#39;alignment length&#39;</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</div>
</div>
<p>Now let’s perform some database searches. You can run the remaining code cells in this section a few times to experiment with searching different query sequences against the same reference database.</p>
<p>This next cell, which is the one that actually performs the database searches, will take a little bit of time to run (maybe up to a minute or two). There is some code in this cell that will track the runtime. As it’s running, think about how many query sequences we’re searching against how many reference sequences, and refer back to the number of sequences in the full reference database. Does this strategy seem scalable to millions of sequences, which as mentioned above might be our ultimate goal? When you know the per-sequence runtime of this search, estimate how long it would take to do this in seconds for one million sequences. Convert the time in seconds to a unit that will be more meaningful to you.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">current_queries</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">local_alignment_search</span><span class="p">(</span><span class="n">current_queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">)</span>
<span class="n">stop_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Runtime: </span><span class="si">%1.4f</span><span class="s2"> sec per query&quot;</span> <span class="o">%</span> <span class="p">((</span><span class="n">stop_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_queries</span><span class="p">)))</span>
<span class="n">results</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Runtime: 2.9513 sec per query
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>reference taxonomy</th>
      <th>percent similarity</th>
      <th>alignment length</th>
      <th>score</th>
    </tr>
    <tr>
      <th>query</th>
      <th>reference</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">354971</th>
      <th>211339</th>
      <td>k__Bacteria; p__Firmicutes; c__Clostridia; o__...</td>
      <td>95.918367</td>
      <td>196</td>
      <td>352</td>
    </tr>
    <tr>
      <th>543173</th>
      <td>k__Bacteria; p__Firmicutes; c__Bacilli; o__Lac...</td>
      <td>90.816327</td>
      <td>196</td>
      <td>302</td>
    </tr>
    <tr>
      <th>354905</th>
      <td>k__Bacteria; p__Firmicutes; c__Bacilli; o__Lac...</td>
      <td>86.666667</td>
      <td>195</td>
      <td>258</td>
    </tr>
    <tr>
      <th>744387</th>
      <td>k__Bacteria; p__Firmicutes; c__Bacilli; o__Lac...</td>
      <td>86.082474</td>
      <td>194</td>
      <td>251</td>
    </tr>
    <tr>
      <th>297314</th>
      <td>k__Bacteria; p__Firmicutes; c__Bacilli; o__Lac...</td>
      <td>85.204082</td>
      <td>196</td>
      <td>247</td>
    </tr>
    <tr>
      <th rowspan="5" valign="top">326869</th>
      <th>4445752</th>
      <td>k__Bacteria; p__Proteobacteria; c__Alphaproteo...</td>
      <td>95.000000</td>
      <td>200</td>
      <td>350</td>
    </tr>
    <tr>
      <th>349639</th>
      <td>k__Bacteria; p__Proteobacteria; c__Alphaproteo...</td>
      <td>92.500000</td>
      <td>200</td>
      <td>325</td>
    </tr>
    <tr>
      <th>616682</th>
      <td>k__Bacteria; p__Proteobacteria; c__Alphaproteo...</td>
      <td>92.500000</td>
      <td>200</td>
      <td>325</td>
    </tr>
    <tr>
      <th>766020</th>
      <td>k__Bacteria; p__Proteobacteria; c__Alphaproteo...</td>
      <td>92.000000</td>
      <td>200</td>
      <td>320</td>
    </tr>
    <tr>
      <th>4714</th>
      <td>k__Bacteria; p__Proteobacteria; c__Alphaproteo...</td>
      <td>92.000000</td>
      <td>200</td>
      <td>320</td>
    </tr>
    <tr>
      <th rowspan="5" valign="top">1111024</th>
      <th>4438586</th>
      <td>k__Bacteria; p__Gemmatimonadetes; c__Gemmatimo...</td>
      <td>88.613861</td>
      <td>202</td>
      <td>284</td>
    </tr>
    <tr>
      <th>4452903</th>
      <td>k__Bacteria; p__Gemmatimonadetes; c__Gemmatimo...</td>
      <td>86.124402</td>
      <td>209</td>
      <td>276</td>
    </tr>
    <tr>
      <th>212819</th>
      <td>k__Bacteria; p__Gemmatimonadetes; c__Gemmatimo...</td>
      <td>87.254902</td>
      <td>204</td>
      <td>269</td>
    </tr>
    <tr>
      <th>1148064</th>
      <td>k__Bacteria; p__Gemmatimonadetes; c__Gemmatimo...</td>
      <td>86.893204</td>
      <td>206</td>
      <td>266</td>
    </tr>
    <tr>
      <th>1813677</th>
      <td>k__Bacteria; p__Gemmatimonadetes; c__Gemmatimo...</td>
      <td>86.274510</td>
      <td>204</td>
      <td>264</td>
    </tr>
    <tr>
      <th rowspan="5" valign="top">1726426</th>
      <th>1726426</th>
      <td>k__Bacteria; p__Proteobacteria; c__Gammaproteo...</td>
      <td>100.000000</td>
      <td>200</td>
      <td>400</td>
    </tr>
    <tr>
      <th>197286</th>
      <td>k__Bacteria; p__Proteobacteria; c__Gammaproteo...</td>
      <td>97.500000</td>
      <td>200</td>
      <td>375</td>
    </tr>
    <tr>
      <th>540402</th>
      <td>k__Bacteria; p__Proteobacteria; c__Gammaproteo...</td>
      <td>97.000000</td>
      <td>200</td>
      <td>370</td>
    </tr>
    <tr>
      <th>4217232</th>
      <td>k__Bacteria; p__Proteobacteria; c__Gammaproteo...</td>
      <td>97.000000</td>
      <td>200</td>
      <td>370</td>
    </tr>
    <tr>
      <th>736735</th>
      <td>k__Bacteria; p__Proteobacteria; c__Gammaproteo...</td>
      <td>96.500000</td>
      <td>200</td>
      <td>365</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Now, let’s try to answer our initial question: what is the most likely taxonomic annotation for each of our query sequences? Spend a few minutes reviewing this information, and write down what you think the most likely taxonomic annotation is for each of the query sequences. Here are some hints to help you out:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">o</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, and <code class="docutils literal notranslate"><span class="pre">s</span></code> refer to <em>kingdom</em>, <em>phylum</em>, <em>class</em>, <em>order</em>, <em>family</em>, <em>genus</em>, and <em>species</em>, respectively. If you see an annotation for a reference sequence that looks like <code class="docutils literal notranslate"><span class="pre">g__</span></code>, that means that the genus is unknown for that sequence.</p></li>
<li><p>Just as the reference taxonomy annotations don’t always go down to the species level, your taxonomic annotations don’t have to either. Not assigning at a given level implies that you’re uncertain about what the annotation should be at that level, and it’s usually better just to indicate that you’re uncertain rather than make a bad guess. If you’re uncertain of what the species is, assign the query <code class="docutils literal notranslate"><span class="pre">s__</span></code> and try to decide what the most likely genus is. If you’re uncertain of the genus, assign <code class="docutils literal notranslate"><span class="pre">g__</span></code>, and try to decide what the most likely family is…</p></li>
<li><p>As you look at each of the reference taxonomy annotations below, refer back to the table above to look at the percent similarity between each query and reference, and maybe the length of the alignments and their scores. These values give you an idea of how confident you should be in each of your taxonomic annotations.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">current_queries</span><span class="p">:</span>
    <span class="n">q_id</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Closest taxonomies for query </span><span class="si">%s</span><span class="s1"> (in order):&#39;</span> <span class="o">%</span> <span class="n">q_id</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;reference taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Closest taxonomies for query 354971 (in order):
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__; g__; s__
  k__Bacteria; p__Firmicutes; c__Bacilli; o__Lactobacillales; f__Lactobacillaceae; g__Lactobacillus; s__
  k__Bacteria; p__Firmicutes; c__Bacilli; o__Lactobacillales; f__Lactobacillaceae; g__Lactobacillus; s__
  k__Bacteria; p__Firmicutes; c__Bacilli; o__Lactobacillales; f__Lactobacillaceae; g__Lactobacillus; s__
  k__Bacteria; p__Firmicutes; c__Bacilli; o__Lactobacillales; f__; g__; s__

Closest taxonomies for query 326869 (in order):
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__; f__; g__; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Rhizobiales; f__; g__; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Rhizobiales; f__Hyphomicrobiaceae; g__Rhodoplanes; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Rhizobiales; f__Bradyrhizobiaceae; g__; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Rhizobiales; f__Beijerinckiaceae; g__; s__

Closest taxonomies for query 1111024 (in order):
  k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__Gemmatimonadales; f__Ellin5301; g__; s__
  k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__; f__; g__; s__
  k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__; f__; g__; s__
  k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__; f__; g__; s__
  k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__KD8-87; f__; g__; s__

Closest taxonomies for query 1726426 (in order):
  k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Enterobacteriales; f__Enterobacteriaceae; g__Serratia; s__
  k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Enterobacteriales; f__Enterobacteriaceae; g__; s__
  k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Enterobacteriales; f__Enterobacteriaceae; g__; s__
  k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Enterobacteriales; f__Enterobacteriaceae; g__Klebsiella; s__
  k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Enterobacteriales; f__Enterobacteriaceae; g__; s__
</pre></div>
</div>
</div>
</div>
<p>Because we have taxonomic annotations for all of the Greengenes sequences (though as you probably have noticed by now, they differ in their specificity), we can next look at taxonomy associated with each of our queries in Greengenes. How do your annotations compare to those from Greengenes, which we’ll print out in the next cell?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">current_queries</span><span class="p">:</span>
    <span class="n">q_id</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Known taxonomy for query </span><span class="si">%s</span><span class="s1">:</span><span class="se">\n</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q_id</span><span class="p">,</span> <span class="n">reference_taxonomy</span><span class="p">[</span><span class="n">q_id</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Known taxonomy for query 354971:
 k__Bacteria; p__Firmicutes; c__Bacilli; o__Lactobacillales; f__Lactobacillaceae; g__Lactobacillus; s__

Known taxonomy for query 326869:
 k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__; f__; g__; s__

Known taxonomy for query 1111024:
 k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__Gemmatimonadales; f__; g__; s__

Known taxonomy for query 1726426:
 k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Enterobacteriales; f__Enterobacteriaceae; g__Serratia; s__
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="reducing-the-runtime-for-database-searches">
<h2>Reducing the runtime for database searches<a class="headerlink" href="#reducing-the-runtime-for-database-searches" title="Permalink to this headline">¶</a></h2>
<p>In the examples above, it’s taking on the order of 5-15 seconds to search a single sequence against our subset of Greengenes. This makes sense when you think about the computations that are being performed. For every sequence in our reference database (5000, if you haven’t modified the database subsampling step) it is computing the <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(T\)</span> matrices described in the Pairwise Alignment chapter, and then tracing back the matrix to compute the aligned sequences. Given all of that, the fact that computation only takes 5-15 seconds is pretty incredible. However, that doesn’t change the fact that this doesn’t scale to real-world applications because we’d have to wait way too long for results. Performing all pairwise alignments is prohibitively expensive for database searching.</p>
<p>As we discussed in the previous chapter, the run time of pairwise alignment scales quadratically with sequence length. Database searching, at least in the example we’re exploring in this chapter, is a bit of a different problem however. Our sequence lengths aren’t changing, but rather it takes a long time because we’re performing a computationally expensive step, pairwise alignment, many times. Our database is fixed in that the number of sequences in it doesn’t change and the sequences themselves don’t change. Our query sequences are all exactly the same length in this example (remember that we set that above, when we sliced a single region from reference database sequences to create our query sequences). Let’s explore how the runtime of this database search scales under these constraints.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="k">def</span> <span class="nf">tabulate_local_alignment_search_runtime</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">n_query_sequences</span><span class="p">,</span>
                                            <span class="n">n_reference_sequences</span><span class="p">,</span> <span class="n">search_function</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># we&#39;ll iterate over the pairs of number of query sequences</span>
    <span class="c1"># and number of reference sequences, and compute the runtime</span>
    <span class="c1"># of the database search three times for each pair (so we</span>
    <span class="c1"># have some idea of the variance in the runtimes). this is</span>
    <span class="c1"># achieved here with a nested for loop (i.e., a for loop</span>
    <span class="c1"># within a for loop).</span>
    <span class="k">for</span> <span class="n">nq</span><span class="p">,</span> <span class="n">nr</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">n_query_sequences</span><span class="p">,</span> <span class="n">n_reference_sequences</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># select nq query sequences at random</span>
            <span class="n">current_queries</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">nq</span><span class="p">)</span>
            <span class="c1"># select nr reference sequences at random</span>
            <span class="n">temp_reference_db</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">reference_db</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">nr</span><span class="p">)</span>
            <span class="c1"># run the search and store its runtime</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">search_function</span><span class="p">(</span><span class="n">current_queries</span><span class="p">,</span> <span class="n">temp_reference_db</span><span class="p">)</span>
            <span class="n">stop_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">median_query_sequence_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">current_queries</span><span class="p">])</span>
            <span class="n">median_reference_sequence_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">temp_reference_db</span><span class="p">])</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">median_query_sequence_len</span><span class="p">,</span> <span class="n">median_reference_sequence_len</span><span class="p">,</span>
                         <span class="n">stop_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span>
    <span class="n">runtimes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Number of query seqs&quot;</span><span class="p">,</span> <span class="s2">&quot;Number of reference seqs&quot;</span><span class="p">,</span>
                                     <span class="s2">&quot;Median query seq length&quot;</span><span class="p">,</span> <span class="s2">&quot;Median reference seq length&quot;</span><span class="p">,</span>
                                     <span class="s2">&quot;Runtime (s)&quot;</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">runtimes</span>

<span class="c1"># we&#39;ll temporarily work with a smaller reference database</span>
<span class="c1"># so this will run a lot faster. this will be of fixed size.</span>
<span class="n">n_reference_sequences</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="c1"># since our database is smaller, we can work with some slightly</span>
<span class="c1"># larger numbers of sequences.</span>
<span class="n">n_query_sequences</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>

<span class="n">local_alignment_search_runtimes</span> <span class="o">=</span> <span class="n">tabulate_local_alignment_search_runtime</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span>
                                                                          <span class="n">n_query_sequences</span><span class="p">,</span> <span class="n">n_reference_sequences</span><span class="p">,</span>
                                                                          <span class="n">local_alignment_search</span><span class="p">)</span>
<span class="n">local_alignment_search_runtimes</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Number of query seqs</th>
      <th>Number of reference seqs</th>
      <th>Median query seq length</th>
      <th>Median reference seq length</th>
      <th>Runtime (s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1434.0</td>
      <td>0.061491</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1425.0</td>
      <td>0.063632</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1422.0</td>
      <td>0.055392</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1420.0</td>
      <td>0.288887</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1431.0</td>
      <td>0.298724</td>
    </tr>
    <tr>
      <th>5</th>
      <td>5.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1430.5</td>
      <td>0.298148</td>
    </tr>
    <tr>
      <th>6</th>
      <td>10.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1412.0</td>
      <td>0.570900</td>
    </tr>
    <tr>
      <th>7</th>
      <td>10.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1446.0</td>
      <td>0.649386</td>
    </tr>
    <tr>
      <th>8</th>
      <td>10.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1423.5</td>
      <td>0.578227</td>
    </tr>
    <tr>
      <th>9</th>
      <td>15.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1449.0</td>
      <td>0.864610</td>
    </tr>
    <tr>
      <th>10</th>
      <td>15.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1424.0</td>
      <td>0.864101</td>
    </tr>
    <tr>
      <th>11</th>
      <td>15.0</td>
      <td>100.0</td>
      <td>200.0</td>
      <td>1425.5</td>
      <td>0.914325</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>This table shows that we’ve tried a few variations on number of query sequences but kept the number of reference sequences constant. There is no variance in the query sequence length, and there is a relatively small amount of variance in reference sequence length (they’re all of the same order of magnitude). There is also relatively little variance in runtime for fixed numbers of query and reference sequences.</p>
<p>This table clearly shows that there is an increase in runtime with an increasing number of query sequences, which we’d of course expect. What we care about is how runtime is increasing as a function of number of query sequences. Let’s plot runtime versus the number of query sequences to help us understand that relationship.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">regplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;Number of query seqs&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;Runtime (s)&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">local_alignment_search_runtimes</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:xlabel=&#39;Number of query seqs&#39;, ylabel=&#39;Runtime (s)&#39;&gt;
</pre></div>
</div>
<img alt="_images/database-searching_28_1.png" src="_images/database-searching_28_1.png" />
</div>
</div>
<p>What we see here is pretty clearly a linear relationship: <span class="math notranslate nohighlight">\(runtime \approx constant \times number\ of\ query\ sequences\)</span>. This is because as we increase the number of query sequences, we’re increasing the number of pairwise alignments that we need to perform. If we have 5 queries and 10 reference sequences, we compute <span class="math notranslate nohighlight">\(5 \times 10 = 50\)</span> pairwise alignments. If we have 10 queries and 100 reference sequences, we compute <span class="math notranslate nohighlight">\(10 \times 100 = 1000\)</span> pairwise alignments. There are a few practical ways to reduce the runtime of a process like this.</p>
<p>The first seems obvious, and even silly at first: perform fewer alignments. This could be achieved in a few ways. You could reduce the number of query sequences, though this might be something a researcher is resistant to: they have some collection of unknown sequences, and they want to know what they all are. You could alternatively reduce the number of reference sequences, but you might run into the same issues there: we wouldn’t want to exclude reference sequences that might provide us with useful information about our query sequences. Finally, we might be able to figure out some ways to perform fewer alignments by not searching all of the query sequences against all of the reference sequences. If we could come up with some procedure to approximate which pairwise alignments were likely to be good (i.e., high scoring) and which were likely to be bad (i.e., low scoring) that is faster than performing the pairwise alignments, we could apply that procedure and only align a pair of sequences when we expect to get a high score. That could potentially allow us to reduce the number of alignments we need to perform, and therefore the runtime of the algorithm.</p>
<p>Another approach to reducing the runtime of this process would be to create a faster implementation of the algorithm (though at some point that won’t be possible anymore), use a faster computer, or run the process in parallel on multiple processors. All of these would be ways to reduce the runtime of the search by some factor <span class="math notranslate nohighlight">\(f\)</span>, where <span class="math notranslate nohighlight">\(new\ runtime \approx \frac{runtime}{f}\)</span>.</p>
<p>In practice, for a production-scale sequence database search application like BLAST, we’d combine these approaches. In the next section we’ll explore ways to reduce the runtime of database searching for a fixed number of query sequences and a fixed number of reference sequences by reducing the number of pairwise alignments that the search function will perform.</p>
</div>
<div class="section" id="heuristic-algorithms">
<h2>Heuristic algorithms<a class="headerlink" href="#heuristic-algorithms" title="Permalink to this headline">¶</a></h2>
<p>As mentioned above, it just takes too long to search individual query sequences against a large database. This problem also isn’t going away anytime soon. While computers are getting faster (or cheaper), the size of our sequences collections are getting bigger because sequencing is getting cheaper. In fact, many people think that obtaining DNA sequences is getting cheaper faster than computers are getting cheaper. As our number of query sequences increases because we are able to obtain more for the same amount of money, and the size of our reference databases increases (because we’re continuously obtaining more sequence data) this will increasingly become a bigger problem. Figures 1 and 2, respectively, illustrate that these are both real-world issues. Notice that the axes are on a log scale in both cases.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">IPython.display</span>
<span class="n">IPython</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">IFrame</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s2">&quot;600&quot;</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="s2">&quot;394&quot;</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="s2">&quot;https://docs.google.com/spreadsheets/d/1vUkUuZsRlLW5U05rXXUn8B2sDYwShkClRMGa8Wiu6bc/pubchart?oid=1844125885&amp;amp;format=interactive&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="600"
    height="394"
    src="https://docs.google.com/spreadsheets/d/1vUkUuZsRlLW5U05rXXUn8B2sDYwShkClRMGa8Wiu6bc/pubchart?oid=1844125885&amp;format=interactive"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>Figure 1: Genome sequencing costs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">IPython.display</span>
<span class="n">IPython</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">IFrame</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s2">&quot;763&quot;</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="s2">&quot;371&quot;</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="s2">&quot;https://docs.google.com/spreadsheets/d/1vUkUuZsRlLW5U05rXXUn8B2sDYwShkClRMGa8Wiu6bc/pubchart?oid=2103353397&amp;amp;format=interactive&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="763"
    height="371"
    src="https://docs.google.com/spreadsheets/d/1vUkUuZsRlLW5U05rXXUn8B2sDYwShkClRMGa8Wiu6bc/pubchart?oid=2103353397&amp;format=interactive"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>Figure 2: Size of GenBank.</p>
<p>One way that we can deal with this problem is by recognizing that most of the alignments that are performed in a database search are unlikely to be very good alignments. An algorithm developer could therefore improve runtime by defining a heuristic (or a rule) that is applied to determine which reference sequences are likely to result in good alignments, and only aligning the query against those. For it to be useful, making the decision to align or not (i.e., applying the heuristic) must be <em>much faster</em> than actually performing the pairwise alignment. The heuristic also needs to make <em>good</em> choices about which reference sequences to align the query against. If the algorithm chooses to not align against a specific reference, that reference is ruled out as a possible result of the database search. A good heuristic for sequence homology searching would therefore be very unlikely to exclude the best alignment(s). When thinking about heuristic algorithms in general, there are some important considerations:</p>
<ol class="simple">
<li><p>How often does the heuristic algorithm fail to get the right answer (in our case, does it make good choices about which reference sequences to align against)?</p></li>
<li><p>How much faster is the heuristic than the “complete” approach, and is that reduction in runtime enough to justify not being guaranteed to get the best answer?</p></li>
</ol>
<p>We’ll now look at a few heuristics in the context of these questions.</p>
<div class="section" id="random-reference-sequence-selection">
<h3>Random reference sequence selection<a class="headerlink" href="#random-reference-sequence-selection" title="Permalink to this headline">¶</a></h3>
<p>Our first heuristic will be a <a class="reference external" href="https://en.wikipedia.org/wiki/Straw_man">straw man</a> that we use as a baseline. We’ll select a random <span class="math notranslate nohighlight">\(p\%\)</span> of the reference sequences to align our query against. This will clearly result in a large decrease in the number of sequence alignments that we need to perform because we’ll go from performing <span class="math notranslate nohighlight">\(R_s\)</span> (the reference database size) sequence alignments to <span class="math notranslate nohighlight">\(p \times R_s\)</span> sequence alignments for each query sequence <span class="math notranslate nohighlight">\(q_i\)</span>.</p>
<p>Here’s the source code for this. You can see that we’re just wrapping our <code class="docutils literal notranslate"><span class="pre">local_alignment_search</span></code> function in a function that samples down to <span class="math notranslate nohighlight">\(p\%\)</span> of the reference sequences.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">heuristic_local_alignment_search_random</span><span class="p">(</span>
        <span class="n">queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">aligner</span><span class="o">=</span><span class="n">local_pairwise_align_ssw</span><span class="p">):</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_db</span><span class="p">))</span>
    <span class="n">database_subset</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">reference_db</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">local_alignment_search</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">database_subset</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">aligner</span><span class="o">=</span><span class="n">aligner</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s select some new queries and see how the results compare to our known taxonomies.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">current_queries</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">heuristic_local_alignment_search_random</span><span class="p">(</span><span class="n">current_queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>

<span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">current_queries</span><span class="p">:</span>
    <span class="n">q_id</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Closest taxonomies for query </span><span class="si">%s</span><span class="s1"> (in order):&#39;</span> <span class="o">%</span> <span class="n">q_id</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;reference taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Closest taxonomies for query 4366045 (in order):
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Veillonellaceae; g__; s__
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Peptostreptococcaceae; g__; s__
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Veillonellaceae; g__Sporomusa; s__
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Ruminococcaceae; g__; s__
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Ruminococcaceae; g__Ruminococcus; s__flavefaciens

Closest taxonomies for query 1111024 (in order):
  k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__Gemmatimonadales; f__Ellin5301; g__; s__
  k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__C114; f__; g__; s__
  k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__Gemmatimonadales; f__; g__; s__
  k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__Gemmatimonadales; f__Gemmatimonadaceae; g__Gemmatimonas; s__
  k__Bacteria; p__Verrucomicrobia; c__Opitutae; o__; f__; g__; s__

Closest taxonomies for query 2729797 (in order):
  k__Bacteria; p__Proteobacteria; c__Betaproteobacteria; o__Burkholderiales; f__Oxalobacteraceae; g__; s__
  k__Bacteria; p__Proteobacteria; c__Betaproteobacteria; o__Burkholderiales; f__Comamonadaceae; g__; s__
  k__Bacteria; p__Proteobacteria; c__Betaproteobacteria; o__Burkholderiales; f__Oxalobacteraceae; g__; s__
  k__Bacteria; p__Proteobacteria; c__Betaproteobacteria; o__Thiobacterales; f__; g__; s__
  k__Bacteria; p__Proteobacteria; c__Betaproteobacteria; o__Rhodocyclales; f__Rhodocyclaceae; g__; s__

Closest taxonomies for query 864506 (in order):
  k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Chromatiales; f__; g__; s__
  k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Alteromonadales; f__OM60; g__; s__
  k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Alteromonadales; f__OM60; g__; s__
  k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Alteromonadales; f__Alteromonadaceae; g__Marinobacter; s__
  k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Alteromonadales; f__Alteromonadaceae; g__nsmpVI18; s__

Closest taxonomies for query 937848 (in order):
  k__Bacteria; p__Verrucomicrobia; c__[Spartobacteria]; o__[Chthoniobacterales]; f__[Chthoniobacteraceae]; g__; s__
  k__Bacteria; p__Verrucomicrobia; c__[Spartobacteria]; o__[Chthoniobacterales]; f__[Chthoniobacteraceae]; g__DA101; s__
  k__Bacteria; p__Verrucomicrobia; c__[Methylacidiphilae]; o__S-BQ2-57; f__; g__; s__
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Thermoanaerobacterales; f__Thermoanaerobacteraceae; g__Thermoanaerobacter; s__uzonensis
  k__Bacteria; p__Chloroflexi; c__S085; o__; f__; g__; s__

Closest taxonomies for query 4336536 (in order):
  k__Bacteria; p__OD1; c__SM2F11; o__; f__; g__; s__
  k__Bacteria; p__Acidobacteria; c__Acidobacteria-6; o__iii1-15; f__; g__; s__
  k__Bacteria; p__Acidobacteria; c__Acidobacteria-6; o__iii1-15; f__; g__; s__
  k__Bacteria; p__Acidobacteria; c__Acidobacteria-6; o__iii1-15; f__; g__; s__
  k__Bacteria; p__Acidobacteria; c__Acidobacteria-6; o__iii1-15; f__; g__; s__

Closest taxonomies for query 774561 (in order):
  k__Bacteria; p__Actinobacteria; c__Actinobacteria; o__Actinomycetales; f__Micrococcaceae; g__; s__
  k__Bacteria; p__Actinobacteria; c__Actinobacteria; o__Actinomycetales; f__Microbacteriaceae; g__; s__
  k__Bacteria; p__Actinobacteria; c__Actinobacteria; o__Actinomycetales; f__Bogoriellaceae; g__Georgenia; s__
  k__Bacteria; p__Actinobacteria; c__Actinobacteria; o__Actinomycetales; f__Pseudonocardiaceae; g__Pseudonocardia; s__
  k__Bacteria; p__Actinobacteria; c__Actinobacteria; o__Actinomycetales; f__Nocardioidaceae; g__; s__

Closest taxonomies for query 4353245 (in order):
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Rhodobacterales; f__Rhodobacteraceae; g__Paracoccus; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Rhizobiales; f__Hyphomicrobiaceae; g__Rhodoplanes; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Rhodospirillales; f__Rhodospirillaceae; g__; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__; f__; g__; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Rhodobacterales; f__Rhodobacteraceae; g__; s__

Closest taxonomies for query 92144 (in order):
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Lachnospiraceae; g__Blautia; s__
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Lachnospiraceae; g__; s__
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Lachnospiraceae; g__; s__
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Lachnospiraceae; g__[Ruminococcus]; s__
  k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__; g__; s__

Closest taxonomies for query 3394691 (in order):
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Kiloniellales; f__Kiloniellaceae; g__; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Rhodospirillales; f__Rhodospirillaceae; g__; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__; f__; g__; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Sphingomonadales; f__Sphingomonadaceae; g__Kaistobacter; s__
  k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__; f__; g__; s__
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">current_queries</span><span class="p">:</span>
    <span class="n">q_id</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Known taxonomy for query </span><span class="si">%s</span><span class="s1">:</span><span class="se">\n</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q_id</span><span class="p">,</span> <span class="n">reference_taxonomy</span><span class="p">[</span><span class="n">q_id</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Known taxonomy for query 4366045:
 k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Veillonellaceae; g__BSV43; s__
Known taxonomy for query 1111024:
 k__Bacteria; p__Gemmatimonadetes; c__Gemmatimonadetes; o__Gemmatimonadales; f__; g__; s__
Known taxonomy for query 2729797:
 k__Bacteria; p__Proteobacteria; c__Betaproteobacteria; o__Burkholderiales; f__Oxalobacteraceae; g__; s__
Known taxonomy for query 864506:
 k__Bacteria; p__Proteobacteria; c__Gammaproteobacteria; o__Chromatiales; f__; g__; s__
Known taxonomy for query 937848:
 k__Bacteria; p__Verrucomicrobia; c__[Spartobacteria]; o__[Chthoniobacterales]; f__[Chthoniobacteraceae]; g__heteroC45_4W; s__
Known taxonomy for query 4336536:
 k__Bacteria; p__Acidobacteria; c__Acidobacteria-6; o__iii1-15; f__RB40; g__; s__
Known taxonomy for query 774561:
 k__Bacteria; p__Actinobacteria; c__Actinobacteria; o__Actinomycetales; f__Micrococcaceae; g__Microbispora; s__rosea
Known taxonomy for query 4353245:
 k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__Rhodobacterales; f__Rhodobacteraceae; g__; s__
Known taxonomy for query 92144:
 k__Bacteria; p__Firmicutes; c__Clostridia; o__Clostridiales; f__Lachnospiraceae; g__; s__
Known taxonomy for query 3394691:
 k__Bacteria; p__Proteobacteria; c__Alphaproteobacteria; o__BD7-3; f__; g__; s__
</pre></div>
</div>
</div>
</div>
<p>What we need now is a way to know how often we get the “right answer”, and how long this heuristic algorithm takes relative to the complete algorithm. We therefore first need to define what the “right answer” is. How about this: if the most common taxonomy assignment resulting from the database search at <code class="docutils literal notranslate"><span class="pre">taxonomy_levels</span></code> levels of taxonomy (i.e., how deep or specific our assignment is) matches the known taxonomy, then our algorithm has achieved the right answer. We can vary <code class="docutils literal notranslate"><span class="pre">taxonomy_levels</span></code> to see how the different heuristics perform at different levels.</p>
<p>Here’s what this would look like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>

<span class="k">def</span> <span class="nf">evaluate_search</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">reference_taxonomy</span><span class="p">,</span> <span class="n">search_function</span><span class="p">,</span> <span class="n">taxonomy_levels</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">aligner</span><span class="o">=</span><span class="n">local_pairwise_align_ssw</span><span class="p">):</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">search_results</span> <span class="o">=</span> <span class="n">search_function</span><span class="p">(</span><span class="n">current_queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">aligner</span><span class="o">=</span><span class="n">aligner</span><span class="p">)</span>
    <span class="n">stop_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">runtime</span> <span class="o">=</span> <span class="n">stop_time</span> <span class="o">-</span> <span class="n">start_time</span>
    <span class="n">per_query_runtime</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">queries</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
        <span class="n">q_id</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q_id</span><span class="p">)</span>
        <span class="n">q_known_taxonomy</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">reference_taxonomy</span><span class="p">[</span><span class="n">q_id</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;; &#39;</span><span class="p">)[:</span><span class="n">taxonomy_levels</span><span class="p">])</span>
        <span class="n">q_observed_taxonomies</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">search_results</span><span class="p">[</span><span class="s1">&#39;reference taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">]:</span>
            <span class="n">q_observed_taxonomies</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;; &#39;</span><span class="p">)[:</span><span class="n">taxonomy_levels</span><span class="p">])]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">q_observed_taxonomy</span> <span class="o">=</span> <span class="n">q_observed_taxonomies</span><span class="o">.</span><span class="n">most_common</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">q_known_taxonomy</span><span class="p">,</span> <span class="n">q_observed_taxonomy</span><span class="p">))</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Query ID&#39;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Known taxonomy&#39;</span><span class="p">,</span> <span class="s1">&#39;Observed taxonomy&#39;</span><span class="p">])</span>
    <span class="n">number_correct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Known taxonomy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Observed taxonomy&#39;</span><span class="p">])</span>
    <span class="n">fraction_correct</span> <span class="o">=</span> <span class="n">number_correct</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">per_query_runtime</span><span class="p">,</span> <span class="n">fraction_correct</span><span class="p">,</span> <span class="n">data</span>
</pre></div>
</div>
</div>
</div>
<p>First let’s see how this works for our full database search algorithm. What’s the runtime, and how often do we get the correct answer? We’ll start with five levels of taxonomy (which corresponds to the family level). <strong>This step will take a couple of minutes to run, because it’s doing the full database search.</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">taxonomy_levels</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">runtime</span><span class="p">,</span> <span class="n">fraction_correct</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">evaluate_search</span><span class="p">(</span><span class="n">current_queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">reference_taxonomy</span><span class="p">,</span>
                                                  <span class="n">local_alignment_search</span><span class="p">,</span> <span class="n">taxonomy_levels</span><span class="o">=</span><span class="n">taxonomy_levels</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%1.2f</span><span class="s1"> seconds per query sequence&#39;</span> <span class="o">%</span> <span class="n">runtime</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%1.2f%%</span><span class="s1"> correct answers&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fraction_correct</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Result details:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">q_id</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q_id</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Known taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Observed taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.97 seconds per query sequence
70.00% correct answers
Result details:
4366045
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Veillonellaceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Veillonellaceae&#39;)

1111024
  (&#39;k__Bacteria&#39;, &#39;p__Gemmatimonadetes&#39;, &#39;c__Gemmatimonadetes&#39;, &#39;o__Gemmatimonadales&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Gemmatimonadetes&#39;, &#39;c__Gemmatimonadetes&#39;, &#39;o__&#39;, &#39;f__&#39;)

2729797
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Betaproteobacteria&#39;, &#39;o__Burkholderiales&#39;, &#39;f__Oxalobacteraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Betaproteobacteria&#39;, &#39;o__Burkholderiales&#39;, &#39;f__Oxalobacteraceae&#39;)

864506
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Gammaproteobacteria&#39;, &#39;o__Chromatiales&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Gammaproteobacteria&#39;, &#39;o__[Marinicellales]&#39;, &#39;f__[Marinicellaceae]&#39;)

937848
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__[Spartobacteria]&#39;, &#39;o__[Chthoniobacterales]&#39;, &#39;f__[Chthoniobacteraceae]&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__[Spartobacteria]&#39;, &#39;o__[Chthoniobacterales]&#39;, &#39;f__[Chthoniobacteraceae]&#39;)

4336536
  (&#39;k__Bacteria&#39;, &#39;p__Acidobacteria&#39;, &#39;c__Acidobacteria-6&#39;, &#39;o__iii1-15&#39;, &#39;f__RB40&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Acidobacteria&#39;, &#39;c__Acidobacteria-6&#39;, &#39;o__iii1-15&#39;, &#39;f__RB40&#39;)

774561
  (&#39;k__Bacteria&#39;, &#39;p__Actinobacteria&#39;, &#39;c__Actinobacteria&#39;, &#39;o__Actinomycetales&#39;, &#39;f__Micrococcaceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Actinobacteria&#39;, &#39;c__Actinobacteria&#39;, &#39;o__Actinomycetales&#39;, &#39;f__Micrococcaceae&#39;)

4353245
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Rhodobacterales&#39;, &#39;f__Rhodobacteraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Rhodobacterales&#39;, &#39;f__Rhodobacteraceae&#39;)

92144
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Lachnospiraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Lachnospiraceae&#39;)

3394691
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__BD7-3&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Sphingomonadales&#39;, &#39;f__Sphingomonadaceae&#39;)
</pre></div>
</div>
</div>
</div>
<p>Next let’s see how this compares to our random heuristic search algorithm. Try running this a few times, as you might get different answers due to different random selections of the database.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>

<span class="n">heuristic_local_alignment_search_random_10</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">heuristic_local_alignment_search_random</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>

<span class="n">runtime</span><span class="p">,</span> <span class="n">fraction_correct</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">evaluate_search</span><span class="p">(</span><span class="n">current_queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">reference_taxonomy</span><span class="p">,</span>
                                                  <span class="n">heuristic_local_alignment_search_random_10</span><span class="p">,</span> <span class="n">taxonomy_levels</span><span class="o">=</span><span class="n">taxonomy_levels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%1.2f</span><span class="s1"> seconds per query sequence&#39;</span> <span class="o">%</span> <span class="n">runtime</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%1.2f%%</span><span class="s1"> correct answers&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fraction_correct</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Result details:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">q_id</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q_id</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Known taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Observed taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.30 seconds per query sequence
30.00% correct answers
Result details:
4366045
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Veillonellaceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Peptococcaceae&#39;)

1111024
  (&#39;k__Bacteria&#39;, &#39;p__Gemmatimonadetes&#39;, &#39;c__Gemmatimonadetes&#39;, &#39;o__Gemmatimonadales&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__Verrucomicrobiae&#39;, &#39;o__Verrucomicrobiales&#39;, &#39;f__Verrucomicrobiaceae&#39;)

2729797
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Betaproteobacteria&#39;, &#39;o__Burkholderiales&#39;, &#39;f__Oxalobacteraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Betaproteobacteria&#39;, &#39;o__Burkholderiales&#39;, &#39;f__&#39;)

864506
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Gammaproteobacteria&#39;, &#39;o__Chromatiales&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Gammaproteobacteria&#39;, &#39;o__[Marinicellales]&#39;, &#39;f__[Marinicellaceae]&#39;)

937848
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__[Spartobacteria]&#39;, &#39;o__[Chthoniobacterales]&#39;, &#39;f__[Chthoniobacteraceae]&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__&#39;, &#39;o__&#39;, &#39;f__&#39;)

4336536
  (&#39;k__Bacteria&#39;, &#39;p__Acidobacteria&#39;, &#39;c__Acidobacteria-6&#39;, &#39;o__iii1-15&#39;, &#39;f__RB40&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Acidobacteria&#39;, &#39;c__Acidobacteria-6&#39;, &#39;o__iii1-15&#39;, &#39;f__&#39;)

774561
  (&#39;k__Bacteria&#39;, &#39;p__Actinobacteria&#39;, &#39;c__Actinobacteria&#39;, &#39;o__Actinomycetales&#39;, &#39;f__Micrococcaceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Actinobacteria&#39;, &#39;c__Actinobacteria&#39;, &#39;o__Actinomycetales&#39;, &#39;f__Micrococcaceae&#39;)

4353245
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Rhodobacterales&#39;, &#39;f__Rhodobacteraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Rhodobacterales&#39;, &#39;f__Rhodobacteraceae&#39;)

92144
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Lachnospiraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Lachnospiraceae&#39;)

3394691
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__BD7-3&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Sphingomonadales&#39;, &#39;f__Sphingomonadaceae&#39;)
</pre></div>
</div>
</div>
</div>
<p>Again, what’s the runtime, and how often do we get the correct answer? Based on comparison to the full search, what do you think: is this a good heuristic?</p>
<p>After performing many trials of the above searches, I get the correct genus-level assignment about half as often with the random reference database heuristic relative to the full database search. Your results might differ from that due to differences in the random selection of query and reference sequences. Try running all the cells in this section a few times.</p>
<p>Go back to the beginning of this section and try running this check based on fewer levels of taxonomy (i.e., decreased taxonomic specificity, such as the phylum) and on more levels of taxonomy (i.e., increased taxonomic specificity, such as the species level). How does that impact how often we get the right answer?</p>
</div>
<div class="section" id="composition-based-reference-sequence-collection">
<h3>Composition-based reference sequence collection<a class="headerlink" href="#composition-based-reference-sequence-collection" title="Permalink to this headline">¶</a></h3>
<p>While the random selection of database sequences can vastly reduce the runtime for database searching, we don’t get the right answer very often. Let’s try some heuristics that are a bit smarter. How about this: if the overall nucleotide composition of a query sequence is very different than the overall nucleotide composition of a reference sequence, it’s unlikely that the best alignment will result from that pairwise alignment, so don’t align the query to that reference sequence. Given that, how do we define “overall nucleotide composition” in a useful way?</p>
<div class="section" id="gc-content">
<h4>GC content<a class="headerlink" href="#gc-content" title="Permalink to this headline">¶</a></h4>
<p>One metric of sequence composition that we can compute quickly (because remember, this has to be a lot faster than computing the alignment for it to be worth it) is GC content. Let’s define a heuristic that only performs a pairwise alignment for the reference sequences that have the most similar GC content to the query sequence. The number of alignments that we’ll perform will be defined as <code class="docutils literal notranslate"><span class="pre">database_subset_size</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">database_subset_size</span> <span class="o">=</span> <span class="mi">500</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">heuristic_local_alignment_search_gc</span><span class="p">(</span>
        <span class="n">queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">database_subset_size</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">reference_db_gc_contents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aligner</span><span class="o">=</span><span class="n">local_pairwise_align_ssw</span><span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">reference_db_gc_contents</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">reference_db_gc_contents</span> <span class="o">=</span> \
         <span class="p">{</span><span class="n">r</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">gc_content</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reference_db</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
        <span class="n">query_gc_content</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">gc_content</span><span class="p">()</span>
        <span class="n">database_subset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reference_db</span><span class="p">:</span>
            <span class="n">ref_gc_content</span> <span class="o">=</span> <span class="n">reference_db_gc_contents</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]]</span>
            <span class="c1"># find the difference in GC content between the reference and</span>
            <span class="c1"># query. we&#39;ll sort and select our reference sequences by this</span>
            <span class="c1"># value</span>
            <span class="n">database_subset</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">ref_gc_content</span> <span class="o">-</span> <span class="n">query_gc_content</span><span class="p">),</span> <span class="n">r</span><span class="p">))</span>
        <span class="n">database_subset</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">database_subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">database_subset</span><span class="p">[:</span><span class="n">database_subset_size</span><span class="p">]]</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_alignment_search</span><span class="p">(</span>
            <span class="p">[</span><span class="n">q</span><span class="p">],</span> <span class="n">database_subset</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">aligner</span><span class="o">=</span><span class="n">aligner</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>If we run our queries again, how often do we get the right answer? How much did we reduce runtime? Do you think this is a better or worse heuristic than what we implemented above?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">heuristic_local_alignment_search_gc_2</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">heuristic_local_alignment_search_gc</span><span class="p">,</span> <span class="n">database_subset_size</span><span class="o">=</span><span class="n">database_subset_size</span><span class="p">)</span>

<span class="n">runtime</span><span class="p">,</span> <span class="n">fraction_correct</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">evaluate_search</span><span class="p">(</span><span class="n">current_queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">reference_taxonomy</span><span class="p">,</span>
                                                  <span class="n">heuristic_local_alignment_search_gc_2</span><span class="p">,</span> <span class="n">taxonomy_levels</span><span class="o">=</span><span class="n">taxonomy_levels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%1.2f</span><span class="s1"> seconds per query sequence&#39;</span> <span class="o">%</span> <span class="n">runtime</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%1.2f%%</span><span class="s1"> correct answers&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fraction_correct</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Result details:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">q_id</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q_id</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Known taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Observed taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.32 seconds per query sequence
10.00% correct answers
Result details:
4366045
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Veillonellaceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Clostridiaceae&#39;)

1111024
  (&#39;k__Bacteria&#39;, &#39;p__Gemmatimonadetes&#39;, &#39;c__Gemmatimonadetes&#39;, &#39;o__Gemmatimonadales&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Gemmatimonadetes&#39;, &#39;c__Gemmatimonadetes&#39;, &#39;o__&#39;, &#39;f__&#39;)

2729797
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Betaproteobacteria&#39;, &#39;o__Burkholderiales&#39;, &#39;f__Oxalobacteraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Betaproteobacteria&#39;, &#39;o__Burkholderiales&#39;, &#39;f__Comamonadaceae&#39;)

864506
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Gammaproteobacteria&#39;, &#39;o__Chromatiales&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Gammaproteobacteria&#39;, &#39;o__Pseudomonadales&#39;, &#39;f__Moraxellaceae&#39;)

937848
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__[Spartobacteria]&#39;, &#39;o__[Chthoniobacterales]&#39;, &#39;f__[Chthoniobacteraceae]&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__[Pedosphaerae]&#39;, &#39;o__[Pedosphaerales]&#39;, &#39;f__&#39;)

4336536
  (&#39;k__Bacteria&#39;, &#39;p__Acidobacteria&#39;, &#39;c__Acidobacteria-6&#39;, &#39;o__iii1-15&#39;, &#39;f__RB40&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Acidobacteria&#39;, &#39;c__Acidobacteria-6&#39;, &#39;o__iii1-15&#39;, &#39;f__&#39;)

774561
  (&#39;k__Bacteria&#39;, &#39;p__Actinobacteria&#39;, &#39;c__Actinobacteria&#39;, &#39;o__Actinomycetales&#39;, &#39;f__Micrococcaceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Actinobacteria&#39;, &#39;c__Actinobacteria&#39;, &#39;o__Actinomycetales&#39;, &#39;f__Micromonosporaceae&#39;)

4353245
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Rhodobacterales&#39;, &#39;f__Rhodobacteraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Rhodospirillales&#39;, &#39;f__Rhodospirillaceae&#39;)

92144
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Lachnospiraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Lachnospiraceae&#39;)

3394691
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__BD7-3&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__&#39;, &#39;f__&#39;)
</pre></div>
</div>
</div>
</div>
<p>Try increasing and decreasing the number of sequences we’ll align by increasing or decreasing <code class="docutils literal notranslate"><span class="pre">database_subset_size</span></code>. How does this impact the runtime and fraction of time that we get the correct answer?</p>
</div>
<div class="section" id="kmer-content">
<span id="kmer"></span><h4>kmer content<a class="headerlink" href="#kmer-content" title="Permalink to this headline">¶</a></h4>
<p>Another metric of sequence composition is <em>kmer composition</em>. A kmer is simply a word (or list of adjacent characters) of length <em>k</em> found within a sequence. Here are the kmer frequencies in a short DNA sequence. The <code class="docutils literal notranslate"><span class="pre">overlap=True</span></code> parameter here means that our kmers can overlap one another.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">skbio</span>

<span class="n">skbio</span><span class="o">.</span><span class="n">DNA</span><span class="p">(</span><span class="s1">&#39;ACCGTGACCAGTTACCAGTTTGACCAA&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">kmer_frequencies</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;ACCGT&#39;: 1,
 &#39;CCGTG&#39;: 1,
 &#39;CGTGA&#39;: 1,
 &#39;GTGAC&#39;: 1,
 &#39;TGACC&#39;: 2,
 &#39;GACCA&#39;: 2,
 &#39;ACCAG&#39;: 2,
 &#39;CCAGT&#39;: 2,
 &#39;CAGTT&#39;: 2,
 &#39;AGTTA&#39;: 1,
 &#39;GTTAC&#39;: 1,
 &#39;TTACC&#39;: 1,
 &#39;TACCA&#39;: 1,
 &#39;AGTTT&#39;: 1,
 &#39;GTTTG&#39;: 1,
 &#39;TTTGA&#39;: 1,
 &#39;TTGAC&#39;: 1,
 &#39;ACCAA&#39;: 1}
</pre></div>
</div>
</div>
</div>
<p>In our next heuristic, we’ll only align our query to the reference sequences with the largest fraction of the kmers that are observed in the query sequence are also present in the reference sequence. This makes a lot of sense to use as an alignment heuristic: we’re only aligning sequences when it looks like they’ll have multiple length-<code class="docutils literal notranslate"><span class="pre">k</span></code> stretches of nucleotides that are not interrupted by substitutions or insertion/deletion mutations.</p>
<p>In our next heuristic, we’ll only align our query to the reference sequences with the largest fraction of the kmers that are observed in the query sequence. This makes a lot of sense to use as an alignment heuristic: we’re only aligning sequences when it looks like they’ll have multiple length-<code class="docutils literal notranslate"><span class="pre">k</span></code> stretches of nucleotides that are not interrupted by substitutions or insertion/deletion mutations.</p>
<p>Here’s the source code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## TODO: Update this to be Jaccard index (or describe it that way, if it already is)</span>
<span class="k">def</span> <span class="nf">fraction_shared_kmers</span><span class="p">(</span><span class="n">kmer_freqs1</span><span class="p">,</span> <span class="n">kmer_freqs2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the fraction of kmers in kmer_freqs1 that are also in kmer_freqs2</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kmer_freqs1, kmer_freqs2</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If k &lt; 1.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    k-mer counts are not incorporated in this distance metric.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sequence1_kmers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kmer_freqs1</span><span class="p">)</span>
    <span class="n">num_sequence1_kmers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence1_kmers</span><span class="p">)</span>
    <span class="n">sequence2_kmers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kmer_freqs2</span><span class="p">)</span>
    <span class="n">shared_kmers</span> <span class="o">=</span> <span class="n">sequence1_kmers</span> <span class="o">&amp;</span> <span class="n">sequence2_kmers</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_kmers</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_sequence1_kmers</span>

<span class="k">def</span> <span class="nf">heuristic_local_alignment_search_kmers</span><span class="p">(</span>
        <span class="n">queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">database_subset_size</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">reference_db_kmer_frequencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aligner</span><span class="o">=</span><span class="n">local_pairwise_align_ssw</span><span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">reference_db_kmer_frequencies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">reference_db_kmer_frequencies</span> <span class="o">=</span> \
         <span class="p">{</span><span class="n">r</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">kmer_frequencies</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reference_db</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
        <span class="n">query_kmer_frequency</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">kmer_frequencies</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">database_subset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reference_db</span><span class="p">:</span>
            <span class="n">ref_kmer_frequency</span> <span class="o">=</span> <span class="n">reference_db_kmer_frequencies</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">fraction_shared_kmers</span><span class="p">(</span><span class="n">query_kmer_frequency</span><span class="p">,</span> <span class="n">ref_kmer_frequency</span><span class="p">)</span>
            <span class="n">database_subset</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
        <span class="n">database_subset</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">database_subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">database_subset</span><span class="p">[:</span><span class="n">database_subset_size</span><span class="p">]]</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_alignment_search</span><span class="p">(</span>
            <span class="p">[</span><span class="n">q</span><span class="p">],</span> <span class="n">database_subset</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">aligner</span><span class="o">=</span><span class="n">aligner</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="mi">7</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s apply this and see how it does. How does the runtime and fraction of correct assignments compare to our GC content-based search and our full database search?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">heuristic_local_alignment_search_kmers_50</span> <span class="o">=</span> \
<span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">heuristic_local_alignment_search_kmers</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">database_subset_size</span><span class="o">=</span><span class="n">database_subset_size</span><span class="p">)</span>

<span class="n">runtime</span><span class="p">,</span> <span class="n">fraction_correct</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">evaluate_search</span><span class="p">(</span><span class="n">current_queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">reference_taxonomy</span><span class="p">,</span>
                                                  <span class="n">heuristic_local_alignment_search_kmers_50</span><span class="p">,</span>
                                                  <span class="n">taxonomy_levels</span><span class="o">=</span><span class="n">taxonomy_levels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%1.2f</span><span class="s1"> seconds per query sequence&#39;</span> <span class="o">%</span> <span class="n">runtime</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%1.2f%%</span><span class="s1"> correct answers&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fraction_correct</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Result details:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">q_id</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q_id</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Known taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Observed taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5.18 seconds per query sequence
70.00% correct answers
Result details:
4366045
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Veillonellaceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Veillonellaceae&#39;)

1111024
  (&#39;k__Bacteria&#39;, &#39;p__Gemmatimonadetes&#39;, &#39;c__Gemmatimonadetes&#39;, &#39;o__Gemmatimonadales&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Gemmatimonadetes&#39;, &#39;c__Gemmatimonadetes&#39;, &#39;o__&#39;, &#39;f__&#39;)

2729797
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Betaproteobacteria&#39;, &#39;o__Burkholderiales&#39;, &#39;f__Oxalobacteraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Betaproteobacteria&#39;, &#39;o__Burkholderiales&#39;, &#39;f__Oxalobacteraceae&#39;)

864506
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Gammaproteobacteria&#39;, &#39;o__Chromatiales&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Gammaproteobacteria&#39;, &#39;o__[Marinicellales]&#39;, &#39;f__[Marinicellaceae]&#39;)

937848
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__[Spartobacteria]&#39;, &#39;o__[Chthoniobacterales]&#39;, &#39;f__[Chthoniobacteraceae]&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__[Spartobacteria]&#39;, &#39;o__[Chthoniobacterales]&#39;, &#39;f__[Chthoniobacteraceae]&#39;)

4336536
  (&#39;k__Bacteria&#39;, &#39;p__Acidobacteria&#39;, &#39;c__Acidobacteria-6&#39;, &#39;o__iii1-15&#39;, &#39;f__RB40&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Acidobacteria&#39;, &#39;c__Acidobacteria-6&#39;, &#39;o__iii1-15&#39;, &#39;f__RB40&#39;)

774561
  (&#39;k__Bacteria&#39;, &#39;p__Actinobacteria&#39;, &#39;c__Actinobacteria&#39;, &#39;o__Actinomycetales&#39;, &#39;f__Micrococcaceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Actinobacteria&#39;, &#39;c__Actinobacteria&#39;, &#39;o__Actinomycetales&#39;, &#39;f__Micrococcaceae&#39;)

4353245
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Rhodobacterales&#39;, &#39;f__Rhodobacteraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Rhodobacterales&#39;, &#39;f__Rhodobacteraceae&#39;)

92144
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Lachnospiraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Lachnospiraceae&#39;)

3394691
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__BD7-3&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Sphingomonadales&#39;, &#39;f__Sphingomonadaceae&#39;)
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="further-optimizing-composition-based-approaches-by-pre-computing-reference-database-information">
<h4>Further optimizing composition-based approaches by pre-computing reference database information<a class="headerlink" href="#further-optimizing-composition-based-approaches-by-pre-computing-reference-database-information" title="Permalink to this headline">¶</a></h4>
<p>One important feature of composition-based approaches is that, because the reference database doesn’t change very often, we can pre-compute features of the reference sequences and re-use them. This can help us to vastly decrease the runtime of our heuristic searches. For example, the computation of all of the reference database kmer frequencies is a lot of work. If we can compute that outside of our database search, we can avoid doing that step for every database search, and therefore remove that computationally expensive (i.e., slow) step of the process.</p>
<p>Here we’ll compute all of the reference database kmer frequencies. Notice that this step takes about a minute to complete. This is a minute of compute time that we can save on every database search!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">reference_db_kmer_frequencies</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]:</span> <span class="n">r</span><span class="o">.</span><span class="n">kmer_frequencies</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reference_db</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>We’ll now pass our pre-computed kmer frequencies into our search function. How does the runtime and accuracy of this search compare to the searches above? This last database search that we’ve implemented here is very similar to how BLAST works.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">heuristic_local_alignment_search_kmers_50</span> <span class="o">=</span> \
 <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">heuristic_local_alignment_search_kmers</span><span class="p">,</span> <span class="n">reference_db_kmer_frequencies</span><span class="o">=</span><span class="n">reference_db_kmer_frequencies</span><span class="p">,</span>
                   <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">database_subset_size</span><span class="o">=</span><span class="n">database_subset_size</span><span class="p">)</span>

<span class="n">runtime</span><span class="p">,</span> <span class="n">fraction_correct</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">evaluate_search</span><span class="p">(</span><span class="n">current_queries</span><span class="p">,</span> <span class="n">reference_db</span><span class="p">,</span> <span class="n">reference_taxonomy</span><span class="p">,</span>
                                                  <span class="n">heuristic_local_alignment_search_kmers_50</span><span class="p">,</span>
                                                  <span class="n">taxonomy_levels</span><span class="o">=</span><span class="n">taxonomy_levels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%1.2f</span><span class="s1"> seconds per query sequence&#39;</span> <span class="o">%</span> <span class="n">runtime</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%1.2f%%</span><span class="s1"> correct answers&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fraction_correct</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Result details:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">q_id</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q_id</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Known taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Observed taxonomy&#39;</span><span class="p">][</span><span class="n">q_id</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.60 seconds per query sequence
70.00% correct answers
Result details:
4366045
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Veillonellaceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Veillonellaceae&#39;)

1111024
  (&#39;k__Bacteria&#39;, &#39;p__Gemmatimonadetes&#39;, &#39;c__Gemmatimonadetes&#39;, &#39;o__Gemmatimonadales&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Gemmatimonadetes&#39;, &#39;c__Gemmatimonadetes&#39;, &#39;o__&#39;, &#39;f__&#39;)

2729797
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Betaproteobacteria&#39;, &#39;o__Burkholderiales&#39;, &#39;f__Oxalobacteraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Betaproteobacteria&#39;, &#39;o__Burkholderiales&#39;, &#39;f__Oxalobacteraceae&#39;)

864506
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Gammaproteobacteria&#39;, &#39;o__Chromatiales&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Gammaproteobacteria&#39;, &#39;o__[Marinicellales]&#39;, &#39;f__[Marinicellaceae]&#39;)

937848
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__[Spartobacteria]&#39;, &#39;o__[Chthoniobacterales]&#39;, &#39;f__[Chthoniobacteraceae]&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Verrucomicrobia&#39;, &#39;c__[Spartobacteria]&#39;, &#39;o__[Chthoniobacterales]&#39;, &#39;f__[Chthoniobacteraceae]&#39;)

4336536
  (&#39;k__Bacteria&#39;, &#39;p__Acidobacteria&#39;, &#39;c__Acidobacteria-6&#39;, &#39;o__iii1-15&#39;, &#39;f__RB40&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Acidobacteria&#39;, &#39;c__Acidobacteria-6&#39;, &#39;o__iii1-15&#39;, &#39;f__RB40&#39;)

774561
  (&#39;k__Bacteria&#39;, &#39;p__Actinobacteria&#39;, &#39;c__Actinobacteria&#39;, &#39;o__Actinomycetales&#39;, &#39;f__Micrococcaceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Actinobacteria&#39;, &#39;c__Actinobacteria&#39;, &#39;o__Actinomycetales&#39;, &#39;f__Micrococcaceae&#39;)

4353245
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Rhodobacterales&#39;, &#39;f__Rhodobacteraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Rhodobacterales&#39;, &#39;f__Rhodobacteraceae&#39;)

92144
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Lachnospiraceae&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Firmicutes&#39;, &#39;c__Clostridia&#39;, &#39;o__Clostridiales&#39;, &#39;f__Lachnospiraceae&#39;)

3394691
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__BD7-3&#39;, &#39;f__&#39;)
  (&#39;k__Bacteria&#39;, &#39;p__Proteobacteria&#39;, &#39;c__Alphaproteobacteria&#39;, &#39;o__Sphingomonadales&#39;, &#39;f__Sphingomonadaceae&#39;)
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="determining-the-statistical-significance-of-a-pairwise-alignment">
<h2>Determining the statistical significance of a pairwise alignment<a class="headerlink" href="#determining-the-statistical-significance-of-a-pairwise-alignment" title="Permalink to this headline">¶</a></h2>
<p>One thing you may have noticed is that the score you get back for a pairwise alignment is hard to interpret. It’s dependent on the query and reference sequence lengths (and possibly their composition, depending on your substitution matrix). So an important question is how to determine <em>how good</em> a given pairwise alignment is. Here we’ll learn about a statistical approach for answering that.</p>
<div class="section" id="metrics-of-alignment-quality">
<h3>Metrics of alignment quality<a class="headerlink" href="#metrics-of-alignment-quality" title="Permalink to this headline">¶</a></h3>
<p>In the examples above, we compared features such as how long the alignment is (relevant for local but not global alignment), the pairwise similarity between the aligned query and reference, and the score. If you’ve used a system like BLAST, you’ll know that there are other values that are often reported about an alignment, like the number of substitutions, or the number of insertion/deletion (or gap) positions. None of these metrics are useful on their own. Let’s look at an example to see why.</p>
<p>Imagine we’re aligning these two sequences:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GAAGCAGCAC</span>
<span class="n">GAACAGAAC</span>
</pre></div>
</div>
<p>If we tell our search algorithm that we’re interested in the alignment with the fewest number of substitutions, the following alignment would get us zero substitutions, but there are a lot of bases that look homologous which are not aligned.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GAAGCAGCAC</span><span class="o">-----</span>
<span class="n">GAA</span><span class="o">------</span><span class="n">CAGAAC</span>
</pre></div>
</div>
<p>On the other hand, if we want to find the alignment with the fewest number of gaps, this one would get us that result, but we now have a lot of substitution events, and some regions that clearly look misaligned (such as the <code class="docutils literal notranslate"><span class="pre">CAG</span></code> sequence in the middle of both).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GAAGCAGCAC</span>
<span class="n">GAACAGA</span><span class="o">-</span><span class="n">AC</span>
</pre></div>
</div>
<p>The alignment score that has been reported by our pairwise aligners helps us to balance these different features, and we can adjust the scoring scheme to weight things differently (e.g., so that gaps are penalized more or less than certain substitutions). The problem is that the scores are hard to interpret, particularly when we have only one or a few of them.</p>
</div>
<div class="section" id="false-positives-false-negatives-p-values-and-alpha">
<h3>False positives, false negatives, p-values, and alpha<a class="headerlink" href="#false-positives-false-negatives-p-values-and-alpha" title="Permalink to this headline">¶</a></h3>
<p>Remember that an alignment of a pair of sequences represents a hypothesis about homology between those sequences. One way that we think about determining if an alignment is good or not is to ask: <em>what fraction of the time would I obtain a score at least this good if my sequences are not homologous?</em> This fraction is usually referred to as our <em>p-value</em>, and this is computed in many different ways. If our p-value is high (e.g., 25%), then our alignment is probably not very good since it means that many non-homologous pairs of sequences would achieve a score at least that high. If our p-value is low (say 0.001%), then our alignment is probably good since scores that high are achieved only infrequently.</p>
<p>Our threshold for defining what we consider to be a high versus low p-value is dependent on how often we’re willing to be wrong. We would set this value, which is usually referred to as <span class="math notranslate nohighlight">\(\alpha\)</span>, to some fraction, and if our p-value is less than <span class="math notranslate nohighlight">\(\alpha\)</span>, we say that the alignment is statistically significant. If our p-value is greater than <span class="math notranslate nohighlight">\(\alpha\)</span>, we say that our alignment is not statistically significant.</p>
<p>There are a couple of ways that we could be wrong when we do sequence homology searching, and we need to consider these when we determine what value we want to define as <span class="math notranslate nohighlight">\(\alpha\)</span>. First, we could say a pair of sequences are homologous when they’re not, which would be a <em>false positive</em> or a <em>type 1 error</em>. Or, we could say that a pair of sequences are not homologous when they are, which would be a <em>false negative</em>, or a <em>type 2 error</em>.</p>
<p>If incurring a false positive about 5% of the time is acceptable (i.e., you’re ok with calling a pair of sequences homologous when they actually are not about one in twenty times) then you’d set your <span class="math notranslate nohighlight">\(\alpha\)</span> to 0.05. Setting <span class="math notranslate nohighlight">\(\alpha\)</span> to a value this high likely means that the method will err on the side of false positives, and only infrequently will it say that a pair of sequences are not homologous when they actually are (i.e., achieve a false negative). If <span class="math notranslate nohighlight">\(\alpha\)</span> were set to be very low on the other hand (say, <span class="math notranslate nohighlight">\(1 \times 10^{-50}\)</span>), then you will err on the side of false negatives. Only infrequently will you say that a pair of non-homologous sequences are homologous, but you might call many pairs of homologous sequences non-homologous. You should think of <span class="math notranslate nohighlight">\(\alpha\)</span> as a dial. If you turn the dial toward higher values, you’ll increase your false positive rate and decrease your false negative rate. If you turn the dial toward lower values, you’ll decrease your false positive rate and increase your false negative rate.</p>
<p>There is not a hard-and-fast rule for whether false positives or false negatives are better, which makes choosing <span class="math notranslate nohighlight">\(\alpha\)</span> hard. It’s application specific, so you need to understand the biological question your asking when making this decision, and the ramifications of false positives versus false negatives. In general, when might you prefer to have false positives? When might you prefer to have false negatives?</p>
</div>
<div class="section" id="interpreting-alignment-scores-in-context">
<h3>Interpreting alignment scores in context<a class="headerlink" href="#interpreting-alignment-scores-in-context" title="Permalink to this headline">¶</a></h3>
<p>In this section, we are going to learn about how to interpret alignment scores by empirically determining if a pairwise alignment that we obtain is better than we would expect if the pair of sequences we’re working with were definitely not homologous. For a given pair of sequences that we want to align, we’re first going to align them and compute the score of the alignment. We’re then going to align many pairs of sequences that are similar to the query and reference, but that we know are not homologous. We’ll do this by shuffling or randomizing the order of the bases in the query sequences, and performing another pairwise alignment.</p>
<p>First, we’ll define a function that can generate random sequences for us. This will take a scikit-bio sequence object (either <code class="docutils literal notranslate"><span class="pre">skbio.DNA</span></code>, <code class="docutils literal notranslate"><span class="pre">skbio.RNA</span></code>, or <code class="docutils literal notranslate"><span class="pre">skbio.Protein</span></code>) and a length, and it will randomly generate a sequence of that type and length for us.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="k">def</span> <span class="nf">random_sequence</span><span class="p">(</span><span class="n">moltype</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">alphabet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">moltype</span><span class="o">.</span><span class="n">nondegenerate_chars</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">alphabet</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">moltype</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We can now run this a few times to generate some random sequences:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">random_sequence</span><span class="p">(</span><span class="n">skbio</span><span class="o">.</span><span class="n">DNA</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
--------------------------------------------------------
Stats:
    length: 50
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 46.00%
--------------------------------------------------------
0 ATCGTTCCTA TTCCCCGAGG CCATAGCTTG TTAAGTAAGT CCATCAGGAT
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">random_sequence</span><span class="p">(</span><span class="n">skbio</span><span class="o">.</span><span class="n">DNA</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
--------------------------------------------------------
Stats:
    length: 50
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 60.00%
--------------------------------------------------------
0 GCTAGATGGT GGCGACGCTG GTTCCATCAA ATTGCGCCGC TCGTGCTACC
</pre></div>
</div>
</div>
</div>
<p>Next, we need a function that will shuffle the characters in a sequence, and give us a new sequence back. We’ll use this to generate a sequence that is similar (in length and composition) to our input sequence, but which we know is not homologous. We’ll use Pythons <code class="docutils literal notranslate"><span class="pre">random.shuffle</span></code> function, which randomly re-orders the order of the elements in a sequence, but keeps the composition and length of the sequence the same.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">shuffle_sequence</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="c1"># generate a list of the position indices (numbers) in sequence</span>
    <span class="n">randomized_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)))</span>
    <span class="c1"># randomly rearrange the order of that list</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">randomized_order</span><span class="p">)</span>
    <span class="c1"># return a new sequence, where the positions are shuffled</span>
    <span class="k">return</span> <span class="n">sequence</span><span class="p">[</span><span class="n">randomized_order</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Now we can define a random sequence and shuffle it. Notice how the sequences are different (in their order), but their compositions (e.g., length and GC content) are the same. Shuffling will change the order of the bases, but it won’t change the frequency at which each base is present - it’s exactly analogous to shuffling a deck of cards.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">random_sequence</span><span class="p">(</span><span class="n">skbio</span><span class="o">.</span><span class="n">DNA</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">seq</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
--------------------------------------------------------
Stats:
    length: 50
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 54.00%
--------------------------------------------------------
0 GATAAGAAAT TAACCGCGTG GTGGGGAGAC GGCCCTTGTG TGGCTCAATC
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shuffle_sequence</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
--------------------------------------------------------
Stats:
    length: 50
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 54.00%
--------------------------------------------------------
0 AGGACGGACA GAGTGCTCGG GTCGTTAGAC CACGAGTGAT TCCGATTTGA
</pre></div>
</div>
</div>
</div>
<p>Let’s generate a random query sequence and align it against itself to see what that score would be.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">query_seq</span> <span class="o">=</span> <span class="n">random_sequence</span><span class="p">(</span><span class="n">skbio</span><span class="o">.</span><span class="n">DNA</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">actual_score</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">local_pairwise_align_ssw</span><span class="p">(</span><span class="n">query_seq</span><span class="p">,</span> <span class="n">query_seq</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Score: </span><span class="si">%1.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">actual_score</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Score: 100.00
</pre></div>
</div>
</div>
</div>
<p>Next let’s generate 99 random variants of that sequence with <code class="docutils literal notranslate"><span class="pre">shuffle_sequence</span></code> and compute the pairwise alignment for each of those variants against the query sequence. We’ll then look at the distribution of those scores.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_random_score_distribution</span><span class="p">(</span><span class="n">sequence1</span><span class="p">,</span>
                                       <span class="n">sequence2</span><span class="p">,</span>
                                       <span class="n">n</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span>
                                       <span class="n">aligner</span><span class="o">=</span><span class="n">local_pairwise_align_ssw</span><span class="p">):</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># iterate n times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># generate a randomized version of the first sequence</span>
        <span class="n">random_sequence</span> <span class="o">=</span> <span class="n">shuffle_sequence</span><span class="p">(</span><span class="n">sequence1</span><span class="p">)</span>
        <span class="c1"># align that randomized sequence against the second sequence</span>
        <span class="c1"># and save its score</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">aligner</span><span class="p">(</span><span class="n">random_sequence</span><span class="p">,</span> <span class="n">sequence2</span><span class="p">)</span>
        <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
    <span class="c1"># return the n randomized alignment scores</span>
    <span class="k">return</span> <span class="n">scores</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">random_scores</span> <span class="o">=</span> <span class="n">generate_random_score_distribution</span><span class="p">(</span><span class="n">query_seq</span><span class="p">,</span> <span class="n">query_seq</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">random_scores</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[10, 11, 10, 10, 13, 8, 13, 10, 10, 11, 12, 12, 14, 12, 9, 9, 11, 11, 11, 13, 12, 11, 12, 11, 12, 11, 15, 9, 12, 14, 16, 8, 13, 10, 10, 8, 11, 12, 16, 8, 12, 10, 12, 21, 10, 10, 17, 12, 13, 11, 10, 8, 12, 10, 12, 16, 15, 14, 12, 11, 12, 11, 10, 11, 14, 10, 10, 12, 9, 10, 16, 10, 10, 8, 12, 13, 10, 13, 14, 11, 10, 11, 14, 15, 11, 9, 10, 10, 11, 11, 12, 8, 13, 12, 11, 12, 10, 11, 12]
</pre></div>
</div>
</div>
</div>
<p>How does the actual score of aligning the sequence to itself compare to the score of aligning it to many similar but non-homologous sequences? Let’s plot these to get a better idea.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="k">def</span> <span class="nf">plot_score_distribution</span><span class="p">(</span><span class="n">actual_score</span><span class="p">,</span> <span class="n">random_scores</span><span class="p">):</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">distplot</span><span class="p">(</span><span class="n">random_scores</span><span class="p">,</span> <span class="n">kde</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Random scores&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">actual_score</span><span class="p">,</span> <span class="n">actual_score</span><span class="p">],</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">(),</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Actual score&quot;</span><span class="p">)</span>
    <span class="c1"># set the range of the x axis to be zero through 110% of the actual score</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">actual_score</span> <span class="o">+</span> <span class="n">actual_score</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;large&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_score_distribution</span><span class="p">(</span><span class="n">actual_score</span><span class="p">,</span> <span class="n">random_scores</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/usr/share/miniconda/envs/iab2/lib/python3.8/site-packages/seaborn/distributions.py:2557: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
  warnings.warn(msg, FutureWarning)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:&gt;
</pre></div>
</div>
<img alt="_images/database-searching_79_2.png" src="_images/database-searching_79_2.png" />
</div>
</div>
<p>What does this tell us about our alignment score and therefore about our alignment? Is it good or bad?</p>
<p>We finally have information that we can use to evaluate an alignment score, and therefore to evaluate the quality of an alignment. Let’s use this information to quantify the quality of the alignment by computing a p-value. As we described above, this is simply the probability that we would obtain an alignment score at least this good if the sequences being aligned are not homologous. Since we have a lot of scores now from sequences that are similar but not homologous, if we just count how many are at least as high as our actual score and divide by the number of scores we compute, that is an empirical (data-driven) way of determining our p-value.</p>
<p>To determine if our alignment is statistically significant, we need to define <span class="math notranslate nohighlight">\(\alpha\)</span> before computing the p-value so the p-value does not impact our choice of <span class="math notranslate nohighlight">\(\alpha\)</span>. Let’s define <span class="math notranslate nohighlight">\(\alpha\)</span> as 0.05. This choice means if we obtain a p-value less than 0.05 we will consider the alignment statistically significant and accept the hypothesis that the sequences are homologous.</p>
<p>Here’s what all of this looks like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_random_score_distribution</span><span class="p">(</span><span class="n">sequence1</span><span class="p">,</span>
                                       <span class="n">sequence2</span><span class="p">,</span>
                                       <span class="n">n</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span>
                                       <span class="n">aligner</span><span class="o">=</span><span class="n">local_pairwise_align_ssw</span><span class="p">):</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># iterate n times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># generate a randomized version of the first sequence</span>
        <span class="n">random_sequence</span> <span class="o">=</span> <span class="n">shuffle_sequence</span><span class="p">(</span><span class="n">sequence1</span><span class="p">)</span>
        <span class="c1"># align that randomized sequence against the second sequence</span>
        <span class="c1"># and save its score</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">aligner</span><span class="p">(</span><span class="n">random_sequence</span><span class="p">,</span> <span class="n">sequence2</span><span class="p">)</span>
        <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
    <span class="c1"># return the n randomized alignment scores</span>
    <span class="k">return</span> <span class="n">scores</span>

<span class="k">def</span> <span class="nf">fraction_better_or_equivalent_alignments</span><span class="p">(</span><span class="n">sequence1</span><span class="p">,</span>
                                             <span class="n">sequence2</span><span class="p">,</span>
                                             <span class="n">n</span> <span class="o">=</span> <span class="mi">99</span><span class="p">,</span>
                                             <span class="n">aligner</span><span class="o">=</span><span class="n">local_pairwise_align_ssw</span><span class="p">):</span>
    <span class="c1"># align sequence1 and sequence2 and store the score of the alignment</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">actual_score</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">aligner</span><span class="p">(</span><span class="n">sequence1</span><span class="p">,</span> <span class="n">sequence2</span><span class="p">)</span>
    <span class="c1"># compute the distribution of randomized scores</span>
    <span class="n">random_scores</span> <span class="o">=</span> <span class="n">generate_random_score_distribution</span><span class="p">(</span><span class="n">sequence1</span><span class="p">,</span>
                                                       <span class="n">sequence2</span><span class="p">,</span>
                                                       <span class="n">n</span><span class="p">,</span>
                                                       <span class="n">aligner</span><span class="o">=</span><span class="n">aligner</span><span class="p">)</span>

    <span class="c1"># count the number of random scores that are at least as good as our</span>
    <span class="c1"># actual score</span>
    <span class="n">count_better</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">random_scores</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="n">actual_score</span><span class="p">:</span>
            <span class="n">count_better</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># return the number of times we observe a score at least as good as the</span>
    <span class="c1"># random score divided by the number of scores we computed. we add one</span>
    <span class="c1"># to the numerator and denominator to account for our actual_score</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">count_better</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fraction of alignment scores at least as good as the alignment score: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
      <span class="n">fraction_better_or_equivalent_alignments</span><span class="p">(</span><span class="n">query_seq</span><span class="p">,</span> <span class="n">query_seq</span><span class="p">,</span> <span class="mi">99</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fraction of alignment scores at least as good as the alignment score: 0.01
</pre></div>
</div>
</div>
</div>
<p>The fraction that we get back here is <code class="docutils literal notranslate"><span class="pre">0.01</span></code>, which is lower than <span class="math notranslate nohighlight">\(\alpha\)</span>, so we would accept the hypothesis that our sequences are homologous.</p>
<p>A few notes on these empirically defined p-values. First, here’s what the formula for computing this looks like:</p>
<p><span class="math notranslate nohighlight">\(p\ value = \frac{number\ of\ computed\ aligned\ scores\ greater\ than\ or\ equal\ to\ the\ actual\ alignment\ score}{number\ of\ alignment\ scores\ computed}\)</span></p>
<p>The numerator and the denominator both include the actual alignment score, so the lowest p-value that can be achieved is <span class="math notranslate nohighlight">\(\frac{1}{99 + 1}\)</span>, where the <span class="math notranslate nohighlight">\(1\)</span> in the numerator corresponds to our actual alignment score (which is of course equal to itself), where the <span class="math notranslate nohighlight">\(99\)</span> in the denominator is the number of permutations, and the <span class="math notranslate nohighlight">\(1\)</span> in the denominator is a constant which corresponds the computation of the actual score. If we increase the number of permutations, say to 999, we could achieve greater precision (more significant digits) in our p-value.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fraction of alignment scores at least as good as the alignment score: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
      <span class="n">fraction_better_or_equivalent_alignments</span><span class="p">(</span><span class="n">query_seq</span><span class="p">,</span> <span class="n">query_seq</span><span class="p">,</span> <span class="mi">999</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fraction of alignment scores at least as good as the alignment score: 0.001
</pre></div>
</div>
</div>
</div>
<p>When we achieve the lowest possible value for a given test, as is the case here, we report the p-value as being less than that value, since we’ve yet to observe a random alignment score at least that high. For example, here we would report something like:</p>
<p><em>The alignment of our query and reference sequence was statistically significant, as determined by comparing our actual alignment score to random variants (<span class="math notranslate nohighlight">\(p &lt; 0.001\)</span>).</em></p>
<p>Let’s now try this for some harder cases, where the query and subject sequences are not identical. First, let’s generate a longer subject sequence at random. Then, we’ll create a random query sequence and compare it. Since we’re doing this in two random steps, we know that these sequences are not homologous. Does the resulting p-value reflect that?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sequence1</span> <span class="o">=</span> <span class="n">random_sequence</span><span class="p">(</span><span class="n">skbio</span><span class="o">.</span><span class="n">DNA</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="n">sequence1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
---------------------------------------------------------------------
Stats:
    length: 250
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 53.20%
---------------------------------------------------------------------
0   GTGCCTACTG AGGGAGCTCA TCGTGCGCAG CATCATACGC ATAACCGAAT TCTATTAGCC
60  GCCCCGCTCA TGTAGCCTGG CCTTACTTCA AAGAAAGTCC GTAACGTGGA GAAACCGAGG
120 CGGTGCCGCG ACTTGTGCTT CGTTTACGCG GGGCCCGAAT GCTACACTTC GCTCGTCGGA
180 CGTCGATCAT AGTGACTGCG ATGAAAATGA AGACCAACTC TTGGTAACGG TAAGAAAAAG
240 TGGTGCGAGA
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sequence2</span> <span class="o">=</span> <span class="n">random_sequence</span><span class="p">(</span><span class="n">skbio</span><span class="o">.</span><span class="n">DNA</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="n">sequence2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
---------------------------------------------------------------------
Stats:
    length: 250
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 45.20%
---------------------------------------------------------------------
0   TATCCGTACG TAGCCCACTT AATGTAGATA TAGTTCTATA AGTCAACAGA TTACACCGCG
60  GAACCGTCAC TAGTTATGTA GCTTCATGAG AATTGCAGGT CGATTATCTG CCCCCACGCT
120 AATAACTAGT GGAATGGCAG CAAGTGGCTT CTACCTGCCT TTATAGAGAG TGACTTGAAT
180 AACATACAAG CGGGCCAAAG CAGGAGGCGA ATTAACTTAG GGCGTAGACA AGTGTCGGGT
240 GTTTGTAGAC
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fraction of alignment scores at least as good as the alignment score: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
      <span class="n">fraction_better_or_equivalent_alignments</span><span class="p">(</span><span class="n">sequence1</span><span class="p">,</span><span class="n">sequence2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fraction of alignment scores at least as good as the alignment score: 0.93
</pre></div>
</div>
</div>
</div>
<p>We’ve now looked at two extremes: where sequences are obviously homologous (because they were the same), and where sequences are obviously not homologous (because they were both independently randomly generated). Next, we’ll explore the region between these, where this gets interesting. We’ll now create a partially randomized sequence to create a pair of sequences where the homology is more obscure. We’ll do this again using the Python <code class="docutils literal notranslate"><span class="pre">random</span></code> module, but this time we’ll introduce mutations only at some positions to create a pair of sequences that are approximately <code class="docutils literal notranslate"><span class="pre">percent_id</span></code> identical.</p>
<p>Let’s define a function to do this, and then compute a sequence that is 95% identical to our <code class="docutils literal notranslate"><span class="pre">sequence1</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">partially_randomize_sequence</span><span class="p">(</span><span class="n">percent_id</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">percent_id</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># choose a base at random that is not the current base</span>
            <span class="c1"># i.e., simulate a substitution event</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">choice</span><span class="p">([</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">sequence</span><span class="o">.</span><span class="n">nondegenerate_chars</span> <span class="k">if</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">c</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">sequence</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sequence1_95</span> <span class="o">=</span> <span class="n">partially_randomize_sequence</span><span class="p">(</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">sequence1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sequence1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
---------------------------------------------------------------------
Stats:
    length: 250
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 53.20%
---------------------------------------------------------------------
0   GTGCCTACTG AGGGAGCTCA TCGTGCGCAG CATCATACGC ATAACCGAAT TCTATTAGCC
60  GCCCCGCTCA TGTAGCCTGG CCTTACTTCA AAGAAAGTCC GTAACGTGGA GAAACCGAGG
120 CGGTGCCGCG ACTTGTGCTT CGTTTACGCG GGGCCCGAAT GCTACACTTC GCTCGTCGGA
180 CGTCGATCAT AGTGACTGCG ATGAAAATGA AGACCAACTC TTGGTAACGG TAAGAAAAAG
240 TGGTGCGAGA
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sequence1_95</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
---------------------------------------------------------------------
Stats:
    length: 250
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 52.00%
---------------------------------------------------------------------
0   GTGCCTACTG AGGGAGCTCA TCGTTCGCAG CTTCATACGG GTAACCGAAT TCTATTAGCC
60  GCCCCGCTCA TGTAGCCTGG CCTTACTTCA AAGAAAGTCC GTAACGTGGC GAAAACGAGG
120 AGGTGCCGCG ACTTGTGCTT CGTTTACGCT GGGCCCGAAT GCTACACTTC GTTCGTCGGA
180 CGTCGATCAT AGTGACTGCG ATGAAAATGA ACACCAACTC TTGGTAACGG TAAGAAATAG
240 TGGTGCGAGA
</pre></div>
</div>
</div>
</div>
<p>Notice how these sequences are almost identical, but have some differences. Let’s apply our approach to determine if it would identify these sequences as being homologous based on <span class="math notranslate nohighlight">\(\alpha = 0.05\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fraction of alignment scores at least as good as the alignment score: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
      <span class="n">fraction_better_or_equivalent_alignments</span><span class="p">(</span><span class="n">sequence1</span><span class="p">,</span> <span class="n">sequence1_95</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fraction of alignment scores at least as good as the alignment score: 0.01
</pre></div>
</div>
</div>
</div>
<p>You likely got a significant p-value there, telling you that the sequences are homologous.</p>
<p>Now let’s simulate much more distantly related sequences by introducing substitutions at many more sites.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sequence1_25</span> <span class="o">=</span> <span class="n">partially_randomize_sequence</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">sequence1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sequence1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
---------------------------------------------------------------------
Stats:
    length: 250
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 53.20%
---------------------------------------------------------------------
0   GTGCCTACTG AGGGAGCTCA TCGTGCGCAG CATCATACGC ATAACCGAAT TCTATTAGCC
60  GCCCCGCTCA TGTAGCCTGG CCTTACTTCA AAGAAAGTCC GTAACGTGGA GAAACCGAGG
120 CGGTGCCGCG ACTTGTGCTT CGTTTACGCG GGGCCCGAAT GCTACACTTC GCTCGTCGGA
180 CGTCGATCAT AGTGACTGCG ATGAAAATGA AGACCAACTC TTGGTAACGG TAAGAAAAAG
240 TGGTGCGAGA
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sequence1_25</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DNA
---------------------------------------------------------------------
Stats:
    length: 250
    has gaps: False
    has degenerates: False
    has definites: True
    GC-content: 48.80%
---------------------------------------------------------------------
0   GTGGATAATA CGTGATAGCA TGGTGAGGAT GAGTTCACCA ATTGACGCTT TTTCTCAGCG
60  GCCTGGGTCA GGGCACCGAT TAGGGGTGAA TCCTAACTCA TTAGCGTGTC ATGACGGAGC
120 TGTAGCCGCG ACATGTCACT AGGGCTGACT AAGGCGAGAC AGGAGCCTGC CCGTAGATGA
180 GGGAAATAAA AGTTTACCAG ATTATAATTA AGACATCCTC TGGGATACGT TAGGATATGG
240 CGGTCTTTGA
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fraction of alignment scores at least as good as the alignment score: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
      <span class="n">fraction_better_or_equivalent_alignments</span><span class="p">(</span><span class="n">sequence1</span><span class="p">,</span> <span class="n">sequence1_25</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fraction of alignment scores at least as good as the alignment score: 0.26
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="exploring-the-limit-of-detection-of-sequence-homology-searches">
<h3>Exploring the limit of detection of sequence homology searches<a class="headerlink" href="#exploring-the-limit-of-detection-of-sequence-homology-searches" title="Permalink to this headline">¶</a></h3>
<p>In the example above, we know that our input sequences are “homologous” because <code class="docutils literal notranslate"><span class="pre">sequence1_25</span></code> and <code class="docutils literal notranslate"><span class="pre">sequence1_95</span></code> are both derived from <code class="docutils literal notranslate"><span class="pre">sequence1</span></code>. Our method detected that homology for <code class="docutils literal notranslate"><span class="pre">sequence1_95</span></code>, when we simulated very closely related sequences, but not for <code class="docutils literal notranslate"><span class="pre">sequence1_25</span></code>, when we simulated much more distantly related sequences. This gives us an idea of the limit of detection of this method, and is a real-world problem that biologists face: as sequences are more divergent from one another, detecting homology becomes increasingly difficult.</p>
<p>Lets run a simulation to gain some more insight into the limit of detection of this method. We’ll run this approach for pairs of sequences where we vary the <code class="docutils literal notranslate"><span class="pre">percent_id</span></code> parameter, and identify when our approach stops identifying sequence pairs as being homologous. This is important to know as a bioinformatician, because it tells us around what pairwise similarity we will no longer be able to identify homology using this approach.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First, let&#39;s define the range of percent identities that we&#39;ll test</span>
<span class="n">percent_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
<span class="c1"># Then, we&#39;ll define the number of random sequences we&#39;ll test at each percent identity</span>
<span class="n">num_trials</span> <span class="o">=</span> <span class="mi">20</span>
<span class="c1"># Then, we&#39;ll define the sequence length that we want to work with, and num_trials random sequences</span>
<span class="n">sequence_length</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">random_sequences</span> <span class="o">=</span> <span class="p">[</span><span class="n">random_sequence</span><span class="p">(</span><span class="n">skbio</span><span class="o">.</span><span class="n">DNA</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_trials</span><span class="p">)]</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">percent_id</span> <span class="ow">in</span> <span class="n">percent_ids</span><span class="p">:</span>
    <span class="c1"># at each percent_id, we&#39;ll track the p-values for each trial (random sequence)</span>
    <span class="n">p_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sequence</span> <span class="ow">in</span> <span class="n">random_sequences</span><span class="p">:</span>
        <span class="c1"># partially randomize the sequence, compute its p-value, and record that p-value</span>
        <span class="n">sequence_at_percent_id</span> <span class="o">=</span> <span class="n">partially_randomize_sequence</span><span class="p">(</span><span class="n">percent_id</span><span class="p">,</span> <span class="n">sequence</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">fraction_better_or_equivalent_alignments</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">sequence_at_percent_id</span><span class="p">)</span>
        <span class="n">p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">percent_id</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">p_values</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">p_values</span><span class="p">)))</span>
<span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Percent id between query and subject&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;Median p-value&quot;</span><span class="p">,</span> <span class="s2">&quot;Mean p-value&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Percent id between query and subject</th>
      <th>Median p-value</th>
      <th>Mean p-value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.00</td>
      <td>0.545</td>
      <td>0.5495</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.05</td>
      <td>0.750</td>
      <td>0.6420</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.10</td>
      <td>0.670</td>
      <td>0.6015</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.15</td>
      <td>0.665</td>
      <td>0.6225</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.20</td>
      <td>0.425</td>
      <td>0.5160</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.25</td>
      <td>0.390</td>
      <td>0.4450</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0.30</td>
      <td>0.280</td>
      <td>0.3005</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0.35</td>
      <td>0.160</td>
      <td>0.3180</td>
    </tr>
    <tr>
      <th>8</th>
      <td>0.40</td>
      <td>0.010</td>
      <td>0.1065</td>
    </tr>
    <tr>
      <th>9</th>
      <td>0.45</td>
      <td>0.010</td>
      <td>0.0815</td>
    </tr>
    <tr>
      <th>10</th>
      <td>0.50</td>
      <td>0.010</td>
      <td>0.0225</td>
    </tr>
    <tr>
      <th>11</th>
      <td>0.55</td>
      <td>0.010</td>
      <td>0.0100</td>
    </tr>
    <tr>
      <th>12</th>
      <td>0.60</td>
      <td>0.010</td>
      <td>0.0100</td>
    </tr>
    <tr>
      <th>13</th>
      <td>0.65</td>
      <td>0.010</td>
      <td>0.0100</td>
    </tr>
    <tr>
      <th>14</th>
      <td>0.70</td>
      <td>0.010</td>
      <td>0.0100</td>
    </tr>
    <tr>
      <th>15</th>
      <td>0.75</td>
      <td>0.010</td>
      <td>0.0100</td>
    </tr>
    <tr>
      <th>16</th>
      <td>0.80</td>
      <td>0.010</td>
      <td>0.0100</td>
    </tr>
    <tr>
      <th>17</th>
      <td>0.85</td>
      <td>0.010</td>
      <td>0.0100</td>
    </tr>
    <tr>
      <th>18</th>
      <td>0.90</td>
      <td>0.010</td>
      <td>0.0100</td>
    </tr>
    <tr>
      <th>19</th>
      <td>0.95</td>
      <td>0.010</td>
      <td>0.0100</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>What does this simulation tell us about our limit of detection for homology (i.e., how similar must a pair of sequences be for us to reliably be able to identify homology between them)? Is this higher or lower than you expected?</p>
<p>With respect to our simulation, I took a few shortcuts here to keep the runtime low. What are some things that could be improved to make this simulation more robust, if we weren’t as concerned about runtime?</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="pairwise-alignment.html" title="previous page">Pairwise sequence alignment</a>
    <a class='right-next' id="next-link" href="machine-learning.html" title="next page">Machine learning in bioinformatics</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By J Gregory Caporaso<br/>
        
            &copy; Copyright 2014-2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>